/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the GitHub repository.
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianRAGPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE_CHAT = "obsidianrag-chat-view";
var DEFAULT_PORT = 8e3;
var DEFAULT_SETTINGS = {
  pythonPath: "/usr/local/bin/obsidianrag-server",
  serverPort: DEFAULT_PORT,
  llmModel: "gemma3",
  autoStartServer: true,
  showSourceLinks: true
};
var ObsidianRAGPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.serverProcess = null;
    this.apiBaseUrl = "";
  }
  async onload() {
    console.log("Loading ObsidianRAG plugin");
    await this.loadSettings();
    this.apiBaseUrl = `http://127.0.0.1:${this.settings.serverPort}`;
    this.registerView(VIEW_TYPE_CHAT, (leaf) => new ChatView(leaf, this));
    this.addRibbonIcon("message-circle", "ObsidianRAG Chat", () => {
      this.activateChatView();
    });
    this.addCommand({
      id: "open-chat",
      name: "Open Chat",
      callback: () => this.activateChatView()
    });
    this.addCommand({
      id: "start-server",
      name: "Start Backend Server",
      callback: () => this.startServer()
    });
    this.addCommand({
      id: "stop-server",
      name: "Stop Backend Server",
      callback: () => this.stopServer()
    });
    this.addCommand({
      id: "check-status",
      name: "Check Server Status",
      callback: () => this.checkServerStatus()
    });
    this.addSettingTab(new ObsidianRAGSettingTab(this.app, this));
    if (this.settings.autoStartServer) {
      setTimeout(() => this.startServer(), 2e3);
    }
  }
  async onunload() {
    console.log("Unloading ObsidianRAG plugin");
    await this.stopServer();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.apiBaseUrl = `http://127.0.0.1:${this.settings.serverPort}`;
  }
  // ==========================================================================
  // View Management
  // ==========================================================================
  async activateChatView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({ type: VIEW_TYPE_CHAT, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  // ==========================================================================
  // Server Management
  // ==========================================================================
  async startServer() {
    var _a, _b;
    if (await this.isServerRunning()) {
      new import_obsidian.Notice("ObsidianRAG server is already running");
      return true;
    }
    new import_obsidian.Notice("Starting ObsidianRAG server...");
    try {
      const vaultPath = this.app.vault.adapter.basePath;
      const { spawn } = require("child_process");
      this.serverProcess = spawn(
        this.settings.pythonPath,
        [
          "serve",
          "--vault",
          vaultPath,
          "--port",
          String(this.settings.serverPort)
        ],
        {
          env: {
            ...process.env,
            OBSIDIANRAG_LLM_MODEL: this.settings.llmModel
          },
          detached: false
        }
      );
      (_a = this.serverProcess.stdout) == null ? void 0 : _a.on("data", (data) => {
        console.log(`[ObsidianRAG] ${data.toString()}`);
      });
      (_b = this.serverProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
        console.error(`[ObsidianRAG] ${data.toString()}`);
      });
      this.serverProcess.on("error", (error) => {
        console.error("[ObsidianRAG] Process error:", error);
        new import_obsidian.Notice(`Failed to start server: ${error.message}`);
      });
      this.serverProcess.on("exit", (code) => {
        console.log(`[ObsidianRAG] Server exited with code ${code}`);
        this.serverProcess = null;
      });
      const ready = await this.waitForServer(3e4);
      if (ready) {
        new import_obsidian.Notice("ObsidianRAG server started successfully!");
        return true;
      } else {
        new import_obsidian.Notice("Server started but not responding. Check logs.");
        return false;
      }
    } catch (error) {
      console.error("[ObsidianRAG] Failed to start server:", error);
      new import_obsidian.Notice(`Failed to start server: ${error}`);
      return false;
    }
  }
  async stopServer() {
    if (this.serverProcess) {
      this.serverProcess.kill();
      this.serverProcess = null;
      new import_obsidian.Notice("ObsidianRAG server stopped");
    }
  }
  async isServerRunning() {
    try {
      const response = await fetch(`${this.apiBaseUrl}/health`, {
        method: "GET",
        signal: AbortSignal.timeout(2e3)
      });
      return response.ok;
    } catch (e) {
      return false;
    }
  }
  async waitForServer(timeout) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (await this.isServerRunning()) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    return false;
  }
  async checkServerStatus() {
    try {
      const response = await fetch(`${this.apiBaseUrl}/health`);
      if (response.ok) {
        const data = await response.json();
        new import_obsidian.Notice(
          `Server OK
Version: ${data.version}
Model: ${data.model}`
        );
      } else {
        new import_obsidian.Notice("Server responded but with an error");
      }
    } catch (e) {
      new import_obsidian.Notice("Server is not running");
    }
  }
  // ==========================================================================
  // API Methods
  // ==========================================================================
  async askQuestion(question) {
    try {
      const response = await fetch(`${this.apiBaseUrl}/ask`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: question })
      });
      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      return {
        result: "",
        sources: [],
        question: "",
        process_time: 0,
        session_id: "",
        error: `Failed to get answer: ${error}`
      };
    }
  }
  /**
   * Ask a question with streaming - yields events as they come
   */
  async *askQuestionStreaming(question) {
    var _a;
    try {
      const response = await fetch(`${this.apiBaseUrl}/ask/stream`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: question })
      });
      if (!response.ok) {
        yield { type: "error", message: `Server error: ${response.status}` };
        return;
      }
      const reader = (_a = response.body) == null ? void 0 : _a.getReader();
      if (!reader) {
        yield { type: "error", message: "No response body" };
        return;
      }
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            try {
              const data = JSON.parse(line.slice(6));
              yield data;
            } catch (e) {
            }
          }
        }
      }
    } catch (error) {
      yield { type: "error", message: `Stream error: ${error}` };
    }
  }
};
var ChatView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    // Status element reference for periodic updates
    this.statusEl = null;
    this.statusInterval = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "ObsidianRAG Chat";
  }
  getIcon() {
    return "message-circle";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("obsidianrag-chat-container");
    const header = container.createDiv("obsidianrag-header");
    header.createEl("h4", { text: "\u{1F916} ObsidianRAG" });
    this.statusEl = header.createSpan("obsidianrag-status");
    this.updateStatus();
    this.statusInterval = window.setInterval(() => this.updateStatus(), 5e3);
    this.containerEl_messages = container.createDiv("obsidianrag-messages");
    this.addMessage({
      role: "assistant",
      content: "Hello! I can answer questions about your notes. What would you like to know?",
      timestamp: /* @__PURE__ */ new Date()
    });
    const inputContainer = container.createDiv("obsidianrag-input-container");
    this.inputEl = inputContainer.createEl("textarea", {
      placeholder: "Ask a question about your notes...",
      cls: "obsidianrag-input"
    });
    const sendButton = inputContainer.createEl("button", {
      text: "Send",
      cls: "obsidianrag-send-button"
    });
    sendButton.addEventListener("click", () => this.sendMessage());
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
  }
  async updateStatus() {
    if (!this.statusEl)
      return;
    const running = await this.plugin.isServerRunning();
    this.statusEl.empty();
    this.statusEl.removeClass("status-online", "status-offline");
    if (running) {
      this.statusEl.addClass("status-online");
      this.statusEl.setText("\u25CF Online");
    } else {
      this.statusEl.addClass("status-offline");
      this.statusEl.setText("\u25CF Offline");
    }
  }
  async sendMessage() {
    const question = this.inputEl.value.trim();
    if (!question)
      return;
    this.addMessage({
      role: "user",
      content: question,
      timestamp: /* @__PURE__ */ new Date()
    });
    this.inputEl.value = "";
    if (!await this.plugin.isServerRunning()) {
      this.addMessage({
        role: "assistant",
        content: "\u26A0\uFE0F Server is not running. Use the command palette to start it, or enable auto-start in settings.",
        timestamp: /* @__PURE__ */ new Date()
      });
      return;
    }
    const progressEl = this.containerEl_messages.createDiv(
      "obsidianrag-message assistant loading"
    );
    const progressContent = progressEl.createDiv("progress-content");
    progressContent.innerHTML = "\u{1F504} <strong>Starting...</strong>";
    const updateProgress = (step, details) => {
      progressContent.innerHTML = `\u{1F504} <strong>${step}</strong>${details ? `<br><span class="progress-details">${details}</span>` : ""}`;
      this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;
    };
    let streamingEl = null;
    let streamingContent = "";
    let retrievedSources = [];
    let ttftLogged = false;
    try {
      let finalAnswer = null;
      for await (const event of this.plugin.askQuestionStreaming(question)) {
        switch (event.type) {
          case "start":
            updateProgress("Connecting...");
            break;
          case "status":
            updateProgress(event.message);
            break;
          case "retrieve_complete":
            retrievedSources = event.sources;
            updateProgress(
              `\u{1F4DA} Retrieved ${event.docs_count} documents`,
              event.sources.slice(0, 3).map(
                (s) => {
                  var _a;
                  return `\u2022 ${((_a = s.source.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || s.source}`;
                }
              ).join("<br>")
            );
            break;
          case "ttft":
            console.log(`\u26A1 [ObsidianRAG] Time to First Token: ${event.seconds}s`);
            ttftLogged = true;
            break;
          case "token":
            if (!streamingEl) {
              progressEl.remove();
              streamingEl = this.containerEl_messages.createDiv(
                "obsidianrag-message assistant streaming"
              );
              const contentDiv = streamingEl.createDiv("message-content");
              contentDiv.createDiv("streaming-text streaming-content");
            }
            streamingContent += event.content;
            const textEl = streamingEl.querySelector(".streaming-text");
            if (textEl) {
              textEl.empty();
              import_obsidian.MarkdownRenderer.render(
                this.app,
                streamingContent,
                textEl,
                "",
                this
              );
            }
            this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;
            break;
          case "generate_complete":
            if (!streamingEl) {
              updateProgress(
                "\u270D\uFE0F Generating answer...",
                event.answer_preview.substring(0, 100) + "..."
              );
            }
            break;
          case "answer":
            finalAnswer = event;
            break;
          case "error":
            progressEl.remove();
            if (streamingEl)
              streamingEl.remove();
            this.addMessage({
              role: "assistant",
              content: `\u274C Error: ${event.message}`,
              timestamp: /* @__PURE__ */ new Date()
            });
            return;
          case "done":
            break;
        }
      }
      if (progressEl.parentElement) {
        progressEl.remove();
      }
      if (finalAnswer) {
        const vaultPath = this.app.vault.adapter.basePath;
        const sourcesWithScores = [];
        for (const s of finalAnswer.sources || []) {
          let source = s.source;
          if (source.startsWith(vaultPath)) {
            source = source.substring(vaultPath.length);
            if (source.startsWith("/")) {
              source = source.substring(1);
            }
          }
          let displayPath = source;
          if (displayPath.endsWith(".md")) {
            displayPath = displayPath.substring(0, displayPath.length - 3);
          }
          const fileWithMd = source.endsWith(".md") ? source : source + ".md";
          const file = this.app.vault.getAbstractFileByPath(fileWithMd) || this.app.vault.getAbstractFileByPath(source);
          if (file) {
            sourcesWithScores.push({
              path: displayPath,
              displayName: displayPath.split("/").pop() || displayPath,
              score: s.score,
              exists: true
            });
          } else {
            const baseName = displayPath.split("/").pop() || displayPath;
            const allFiles = this.app.vault.getMarkdownFiles();
            const matchingFile = allFiles.find(
              (f) => f.basename.toLowerCase() === baseName.toLowerCase()
            );
            if (matchingFile) {
              const matchPath = matchingFile.path.endsWith(".md") ? matchingFile.path.substring(0, matchingFile.path.length - 3) : matchingFile.path;
              sourcesWithScores.push({
                path: matchPath,
                displayName: matchingFile.basename,
                score: s.score,
                exists: true
              });
            } else {
              console.log(`[ObsidianRAG] Skipping non-existent source: ${displayPath}`);
            }
          }
        }
        const seen = /* @__PURE__ */ new Set();
        const uniqueSorted = sourcesWithScores.filter((s) => s.exists !== false).sort((a, b) => b.score - a.score).filter((s) => {
          if (seen.has(s.path))
            return false;
          seen.add(s.path);
          return true;
        });
        if (streamingEl) {
          streamingEl.removeClass("streaming");
          const textEl = streamingEl.querySelector(".streaming-text");
          if (textEl) {
            textEl.removeClass("streaming-content");
            textEl.empty();
            import_obsidian.MarkdownRenderer.render(
              this.app,
              finalAnswer.answer,
              textEl,
              "",
              this
            );
          }
          if (uniqueSorted.length > 0 && this.plugin.settings.showSourceLinks) {
            const sourcesEl = streamingEl.createDiv("message-sources");
            sourcesEl.createEl("strong", { text: "Sources (by relevance): " });
            uniqueSorted.forEach((source, i) => {
              if (i > 0)
                sourcesEl.appendText(" ");
              const sourceContainer = sourcesEl.createSpan("source-item");
              const scoreIndicator = this.getScoreIndicator(source.score);
              sourceContainer.appendText(scoreIndicator);
              if (source.exists !== false) {
                const link = sourceContainer.createEl("a", {
                  text: source.displayName,
                  cls: "internal-link"
                });
                link.addEventListener("click", (e) => {
                  e.preventDefault();
                  this.app.workspace.openLinkText(source.path, "");
                });
              } else {
                sourceContainer.createSpan({
                  text: source.displayName,
                  cls: "source-not-found"
                });
              }
            });
          }
          this.messages.push({
            role: "assistant",
            content: finalAnswer.answer,
            sources: uniqueSorted,
            timestamp: /* @__PURE__ */ new Date()
          });
        } else {
          this.addMessage({
            role: "assistant",
            content: finalAnswer.answer,
            sources: uniqueSorted,
            timestamp: /* @__PURE__ */ new Date()
          });
        }
      }
    } catch (error) {
      progressEl.remove();
      this.addMessage({
        role: "assistant",
        content: `\u274C Error: ${error}`,
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  addMessage(message) {
    this.messages.push(message);
    const messageEl = this.containerEl_messages.createDiv(
      `obsidianrag-message ${message.role}`
    );
    const contentEl = messageEl.createDiv("message-content");
    import_obsidian.MarkdownRenderer.render(
      this.app,
      message.content,
      contentEl,
      "",
      this
    );
    if (message.sources && message.sources.length > 0 && this.plugin.settings.showSourceLinks) {
      const sourcesEl = messageEl.createDiv("message-sources");
      sourcesEl.createEl("strong", { text: "Sources (by relevance): " });
      message.sources.forEach((source, i) => {
        if (i > 0)
          sourcesEl.appendText(" ");
        const sourceContainer = sourcesEl.createSpan("source-item");
        const scoreIndicator = this.getScoreIndicator(source.score);
        sourceContainer.appendText(scoreIndicator);
        if (source.exists !== false) {
          const link = sourceContainer.createEl("a", {
            text: source.displayName,
            cls: "internal-link"
          });
          link.setAttribute("title", `Relevance: ${(source.score * 100).toFixed(1)}%`);
          link.addEventListener("click", (e) => {
            e.preventDefault();
            this.app.workspace.openLinkText(source.path, "");
          });
        } else {
          const span = sourceContainer.createSpan({
            text: source.displayName,
            cls: "source-not-found"
          });
          span.setAttribute("title", `File not found in vault`);
        }
      });
    }
    this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;
  }
  /**
   * Get an emoji indicator based on the relevance score
   */
  getScoreIndicator(score) {
    if (score >= 0.8)
      return "\u{1F7E2}";
    if (score >= 0.6)
      return "\u{1F7E1}";
    if (score >= 0.4)
      return "\u{1F7E0}";
    return "\u{1F534}";
  }
  async onClose() {
    if (this.statusInterval) {
      window.clearInterval(this.statusInterval);
      this.statusInterval = null;
    }
    this.statusEl = null;
  }
};
var ObsidianRAGSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ObsidianRAG Settings" });
    new import_obsidian.Setting(containerEl).setName("ObsidianRAG Command").setDesc("Path to obsidianrag-server script or command").addText(
      (text) => text.setPlaceholder("/usr/local/bin/obsidianrag-server").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
        this.plugin.settings.pythonPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Server Port").setDesc("Port for the backend API server").addText(
      (text) => text.setPlaceholder("8000").setValue(String(this.plugin.settings.serverPort)).onChange(async (value) => {
        const port = parseInt(value) || DEFAULT_PORT;
        this.plugin.settings.serverPort = port;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LLM Model").setDesc("Ollama model to use for answering questions").addDropdown(
      (dropdown) => dropdown.addOption("gemma3", "Gemma 3 (recommended)").addOption("llama3.2", "Llama 3.2").addOption("mistral", "Mistral").addOption("qwen2.5", "Qwen 2.5").addOption("phi3", "Phi 3").setValue(this.plugin.settings.llmModel).onChange(async (value) => {
        this.plugin.settings.llmModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-start Server").setDesc("Automatically start the backend when Obsidian opens").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoStartServer).onChange(async (value) => {
        this.plugin.settings.autoStartServer = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Source Links").setDesc("Display links to source notes in answers").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSourceLinks).onChange(async (value) => {
        this.plugin.settings.showSourceLinks = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Server Controls" });
    new import_obsidian.Setting(containerEl).setName("Start Server").setDesc("Manually start the backend server").addButton(
      (button) => button.setButtonText("Start").onClick(async () => {
        await this.plugin.startServer();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Stop Server").setDesc("Stop the backend server").addButton(
      (button) => button.setButtonText("Stop").onClick(async () => {
        await this.plugin.stopServer();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Check Status").setDesc("Check if the server is running").addButton(
      (button) => button.setButtonText("Check").onClick(async () => {
        await this.plugin.checkServerStatus();
      })
    );
    containerEl.createEl("h3", { text: "Requirements" });
    const helpEl = containerEl.createEl("div", { cls: "setting-item-description" });
    helpEl.innerHTML = `
      <p>This plugin requires:</p>
      <ul>
        <li><strong>Python 3.11+</strong> installed and accessible</li>
        <li><strong>obsidianrag</strong> package: <code>pip install obsidianrag</code></li>
        <li><strong>Ollama</strong> running locally with at least one model</li>
      </ul>
      <p>Install Ollama from <a href="https://ollama.ai">ollama.ai</a></p>
    `;
  }
};
