/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the GitHub repository.
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianRAGPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE_CHAT = "obsidianrag-chat-view";
var DEFAULT_PORT = 8e3;
var MAX_RETRY_ATTEMPTS = 3;
var RETRY_DELAY_MS = 1e3;
var DEFAULT_SETTINGS = {
  pythonPath: "/usr/local/bin/obsidianrag-server",
  serverPort: DEFAULT_PORT,
  llmModel: "gemma3",
  autoStartServer: true,
  showSourceLinks: true,
  useReranker: true,
  hasCompletedSetup: false
};
var ObsidianRAGPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.serverProcess = null;
    this.apiBaseUrl = "";
    this.restartAttempts = 0;
    this.maxRestartAttempts = 3;
    this.isRestarting = false;
    this.statusBarItem = null;
  }
  async onload() {
    console.log("Loading ObsidianRAG plugin");
    await this.loadSettings();
    this.apiBaseUrl = `http://127.0.0.1:${this.settings.serverPort}`;
    this.registerView(VIEW_TYPE_CHAT, (leaf) => new ChatView(leaf, this));
    this.addRibbonIcon("message-circle", "ObsidianRAG Chat", () => {
      this.activateChatView();
    });
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("obsidianrag-status-bar");
    this.updateStatusBar();
    this.addCommand({
      id: "open-chat",
      name: "Open Chat",
      callback: () => this.activateChatView()
    });
    this.addCommand({
      id: "start-server",
      name: "Start Backend Server",
      callback: () => this.startServer()
    });
    this.addCommand({
      id: "stop-server",
      name: "Stop Backend Server",
      callback: () => this.stopServer()
    });
    this.addCommand({
      id: "check-status",
      name: "Check Server Status",
      callback: () => this.checkServerStatus()
    });
    this.addCommand({
      id: "ask-question",
      name: "Ask a Question",
      callback: () => new AskQuestionModal(this.app, this).open()
    });
    this.addCommand({
      id: "reindex-vault",
      name: "Reindex Vault",
      callback: () => this.reindexVault()
    });
    this.addSettingTab(new ObsidianRAGSettingTab(this.app, this));
    if (!this.settings.hasCompletedSetup) {
      new SetupModal(this.app, this).open();
    }
    if (this.settings.autoStartServer) {
      setTimeout(() => this.startServer(), 2e3);
    }
    this.registerInterval(
      window.setInterval(() => this.updateStatusBar(), 1e4)
    );
  }
  async onunload() {
    console.log("Unloading ObsidianRAG plugin");
    await this.stopServer();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.apiBaseUrl = `http://127.0.0.1:${this.settings.serverPort}`;
  }
  // ==========================================================================
  // Status Bar
  // ==========================================================================
  async updateStatusBar() {
    if (!this.statusBarItem)
      return;
    const running = await this.isServerRunning();
    this.statusBarItem.empty();
    if (running) {
      this.statusBarItem.setText("\u{1F916} RAG \u25CF");
      this.statusBarItem.setAttribute("title", "ObsidianRAG: Online - Click to open chat");
      this.statusBarItem.addClass("status-online");
      this.statusBarItem.removeClass("status-offline");
    } else {
      this.statusBarItem.setText("\u{1F916} RAG \u25CB");
      this.statusBarItem.setAttribute("title", "ObsidianRAG: Offline - Click to start server");
      this.statusBarItem.addClass("status-offline");
      this.statusBarItem.removeClass("status-online");
    }
    this.statusBarItem.onClickEvent(() => {
      if (running) {
        this.activateChatView();
      } else {
        this.startServer();
      }
    });
  }
  // ==========================================================================
  // View Management
  // ==========================================================================
  async activateChatView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({ type: VIEW_TYPE_CHAT, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  // ==========================================================================
  // Server Management
  // ==========================================================================
  async startServer() {
    var _a, _b;
    if (await this.isServerRunning()) {
      new import_obsidian.Notice("ObsidianRAG server is already running");
      return true;
    }
    new import_obsidian.Notice("Starting ObsidianRAG server...");
    try {
      const vaultPath = this.app.vault.adapter.basePath;
      const { spawn } = require("child_process");
      const platform = process.platform;
      const spawnOptions = this.getSpawnOptionsForPlatform(platform);
      let command;
      let args;
      if (platform === "win32") {
        command = this.settings.pythonPath;
        args = [
          "serve",
          "--vault",
          `"${vaultPath}"`,
          // Quote path for Windows
          "--port",
          String(this.settings.serverPort)
        ];
      } else {
        command = this.settings.pythonPath;
        args = [
          "serve",
          "--vault",
          vaultPath,
          "--port",
          String(this.settings.serverPort)
        ];
      }
      this.serverProcess = spawn(command, args, spawnOptions);
      (_a = this.serverProcess.stdout) == null ? void 0 : _a.on("data", (data) => {
        console.log(`[ObsidianRAG] ${data.toString()}`);
      });
      (_b = this.serverProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
        console.error(`[ObsidianRAG] ${data.toString()}`);
      });
      this.serverProcess.on("error", (error) => {
        console.error("[ObsidianRAG] Process error:", error);
        new import_obsidian.Notice(`Failed to start server: ${error.message}`);
      });
      this.serverProcess.on("exit", (code) => {
        console.log(`[ObsidianRAG] Server exited with code ${code}`);
        this.serverProcess = null;
        if (this.settings.autoStartServer && !this.isRestarting) {
          this.handleServerCrash(code);
        }
      });
      const ready = await this.waitForServer(3e4);
      if (ready) {
        this.restartAttempts = 0;
        new import_obsidian.Notice("ObsidianRAG server started successfully!");
        this.updateStatusBar();
        return true;
      } else {
        new import_obsidian.Notice("Server started but not responding. Check logs.");
        return false;
      }
    } catch (error) {
      console.error("[ObsidianRAG] Failed to start server:", error);
      new import_obsidian.Notice(`Failed to start server: ${error}`);
      return false;
    }
  }
  async handleServerCrash(exitCode) {
    if (this.restartAttempts >= this.maxRestartAttempts) {
      new import_obsidian.Notice(`Server crashed ${this.maxRestartAttempts} times. Please check logs and restart manually.`);
      this.restartAttempts = 0;
      return;
    }
    this.restartAttempts++;
    this.isRestarting = true;
    const delay = RETRY_DELAY_MS * this.restartAttempts;
    new import_obsidian.Notice(`Server exited with code ${exitCode}. Restarting in ${delay / 1e3}s... (attempt ${this.restartAttempts}/${this.maxRestartAttempts})`);
    await new Promise((resolve) => setTimeout(resolve, delay));
    this.isRestarting = false;
    await this.startServer();
  }
  async stopServer() {
    this.isRestarting = true;
    if (this.serverProcess) {
      this.serverProcess.kill();
      this.serverProcess = null;
      new import_obsidian.Notice("ObsidianRAG server stopped");
    }
    this.isRestarting = false;
    this.updateStatusBar();
  }
  async isServerRunning() {
    try {
      const response = await fetch(`${this.apiBaseUrl}/health`, {
        method: "GET",
        signal: AbortSignal.timeout(2e3)
      });
      return response.ok;
    } catch (e) {
      return false;
    }
  }
  async waitForServer(timeout) {
    const start = Date.now();
    while (Date.now() - start < timeout) {
      if (await this.isServerRunning()) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
    return false;
  }
  async checkServerStatus() {
    try {
      const response = await fetch(`${this.apiBaseUrl}/health`);
      if (response.ok) {
        const data = await response.json();
        new import_obsidian.Notice(
          `Server OK
Version: ${data.version}
Model: ${data.model}`
        );
      } else {
        new import_obsidian.Notice("Server responded but with an error");
      }
    } catch (e) {
      new import_obsidian.Notice("Server is not running");
    }
  }
  // ==========================================================================
  // API Methods
  // ==========================================================================
  async askQuestion(question) {
    try {
      const response = await fetch(`${this.apiBaseUrl}/ask`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: question })
      });
      if (!response.ok) {
        throw new Error(`Server error: ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      return {
        result: "",
        sources: [],
        question: "",
        process_time: 0,
        session_id: "",
        error: `Failed to get answer: ${error}`
      };
    }
  }
  /**
   * Ask a question with streaming - yields events as they come
   */
  async *askQuestionStreaming(question) {
    var _a;
    try {
      const response = await fetch(`${this.apiBaseUrl}/ask/stream`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: question })
      });
      if (!response.ok) {
        yield { type: "error", message: `Server error: ${response.status}` };
        return;
      }
      const reader = (_a = response.body) == null ? void 0 : _a.getReader();
      if (!reader) {
        yield { type: "error", message: "No response body" };
        return;
      }
      const decoder = new TextDecoder();
      let buffer = "";
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            try {
              const data = JSON.parse(line.slice(6));
              yield data;
            } catch (e) {
            }
          }
        }
      }
    } catch (error) {
      yield { type: "error", message: `Stream error: ${error}` };
    }
  }
  /**
   * Get vault statistics from the server
   */
  async getStats() {
    return await this.fetchWithRetry(`${this.apiBaseUrl}/stats`);
  }
  /**
   * Trigger vault reindexing
   */
  async reindexVault() {
    if (!await this.isServerRunning()) {
      new import_obsidian.Notice("Server is not running. Start it first.");
      return false;
    }
    new import_obsidian.Notice("Reindexing vault... This may take a while.");
    try {
      const response = await fetch(`${this.apiBaseUrl}/rebuild_db`, {
        method: "POST",
        signal: AbortSignal.timeout(3e5)
        // 5 min timeout for large vaults
      });
      if (response.ok) {
        const data = await response.json();
        new import_obsidian.Notice(`Reindexing complete! Indexed ${data.total_chunks || "unknown"} chunks.`);
        return true;
      } else {
        new import_obsidian.Notice(`Reindexing failed: ${response.status}`);
        return false;
      }
    } catch (error) {
      new import_obsidian.Notice(`Reindexing failed: ${error}`);
      return false;
    }
  }
  /**
   * Fetch with retry logic
   */
  async fetchWithRetry(url, options = {}, attempts = MAX_RETRY_ATTEMPTS) {
    let lastError = null;
    for (let i = 0; i < attempts; i++) {
      try {
        const response = await fetch(url, {
          ...options,
          signal: AbortSignal.timeout(1e4)
        });
        if (response.ok) {
          return await response.json();
        }
        lastError = new Error(`HTTP ${response.status}`);
      } catch (error) {
        lastError = error;
        if (i < attempts - 1) {
          await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY_MS * (i + 1)));
        }
      }
    }
    console.error(`[ObsidianRAG] Failed after ${attempts} attempts:`, lastError);
    return null;
  }
  /**
   * Get platform-specific spawn options
   */
  getSpawnOptionsForPlatform(platform) {
    const env = {
      ...process.env,
      OBSIDIANRAG_LLM_MODEL: this.settings.llmModel,
      OBSIDIANRAG_USE_RERANKER: this.settings.useReranker ? "true" : "false"
    };
    if (platform === "win32") {
      return {
        shell: true,
        env,
        windowsHide: true
      };
    } else if (platform === "linux") {
      return {
        shell: false,
        env
      };
    } else {
      return {
        shell: false,
        env
      };
    }
  }
  /**
   * Get default Python command based on platform
   */
  getDefaultPythonCommand() {
    const platform = process.platform;
    if (platform === "win32") {
      return "py -m obsidianrag";
    } else if (platform === "linux") {
      return "python3 -m obsidianrag";
    } else {
      return "/usr/local/bin/obsidianrag-server";
    }
  }
};
var SetupModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.currentStep = 0;
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("obsidianrag-setup-modal");
    contentEl.createEl("h2", { text: "\u{1F916} Welcome to ObsidianRAG!" });
    this.contentEl_modal = contentEl.createDiv("setup-content");
    this.showStep(0);
  }
  showStep(step) {
    this.currentStep = step;
    this.contentEl_modal.empty();
    const steps = [
      this.renderRequirements.bind(this),
      this.renderConfiguration.bind(this),
      this.renderComplete.bind(this)
    ];
    if (step < steps.length) {
      steps[step]();
    }
  }
  renderRequirements() {
    const el = this.contentEl_modal;
    el.createEl("h3", { text: "Step 1: Check Requirements" });
    const requirements = el.createEl("ul");
    requirements.createEl("li").innerHTML = "<strong>Python 3.11+</strong> - Required for the backend";
    requirements.createEl("li").innerHTML = "<strong>obsidianrag</strong> package - <code>pip install obsidianrag</code>";
    requirements.createEl("li").innerHTML = "<strong>Ollama</strong> - Local LLM server from <a href='https://ollama.ai'>ollama.ai</a>";
    requirements.createEl("li").innerHTML = "At least one Ollama model - <code>ollama pull gemma3</code>";
    el.createEl("p", {
      text: "Make sure you have all requirements installed before proceeding.",
      cls: "setting-item-description"
    });
    const buttons = el.createDiv("modal-button-container");
    const nextBtn = buttons.createEl("button", { text: "Next \u2192", cls: "mod-cta" });
    nextBtn.addEventListener("click", () => this.showStep(1));
    const skipBtn = buttons.createEl("button", { text: "Skip Setup" });
    skipBtn.addEventListener("click", () => this.completeSetup());
  }
  renderConfiguration() {
    const el = this.contentEl_modal;
    el.createEl("h3", { text: "Step 2: Configuration" });
    new import_obsidian.Setting(el).setName("Backend Command").setDesc("Path to obsidianrag-server or 'obsidianrag' if installed globally").addText((text) => text.setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
      this.plugin.settings.pythonPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(el).setName("Server Port").addText((text) => text.setValue(String(this.plugin.settings.serverPort)).onChange(async (value) => {
      this.plugin.settings.serverPort = parseInt(value) || DEFAULT_PORT;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(el).setName("LLM Model").addDropdown((dropdown) => dropdown.addOption("gemma3", "Gemma 3").addOption("llama3.2", "Llama 3.2").addOption("mistral", "Mistral").addOption("qwen2.5", "Qwen 2.5").setValue(this.plugin.settings.llmModel).onChange(async (value) => {
      this.plugin.settings.llmModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(el).setName("Auto-start server").setDesc("Start the backend automatically when Obsidian opens").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartServer).onChange(async (value) => {
      this.plugin.settings.autoStartServer = value;
      await this.plugin.saveSettings();
    }));
    const buttons = el.createDiv("modal-button-container");
    const backBtn = buttons.createEl("button", { text: "\u2190 Back" });
    backBtn.addEventListener("click", () => this.showStep(0));
    const nextBtn = buttons.createEl("button", { text: "Finish \u2192", cls: "mod-cta" });
    nextBtn.addEventListener("click", () => this.showStep(2));
  }
  renderComplete() {
    const el = this.contentEl_modal;
    el.createEl("h3", { text: "\u2705 Setup Complete!" });
    el.createEl("p", { text: "You're all set to use ObsidianRAG." });
    const tips = el.createEl("ul");
    tips.createEl("li", { text: "Click the \u{1F916} icon in the ribbon to open the chat" });
    tips.createEl("li", { text: "Use Cmd/Ctrl+P and search 'ObsidianRAG' for all commands" });
    tips.createEl("li", { text: "First question may take a moment while the vault is indexed" });
    const buttons = el.createDiv("modal-button-container");
    const startBtn = buttons.createEl("button", { text: "Start Server & Open Chat", cls: "mod-cta" });
    startBtn.addEventListener("click", async () => {
      await this.plugin.startServer();
      this.completeSetup();
      this.plugin.activateChatView();
    });
    const laterBtn = buttons.createEl("button", { text: "Maybe Later" });
    laterBtn.addEventListener("click", () => this.completeSetup());
  }
  async completeSetup() {
    this.plugin.settings.hasCompletedSetup = true;
    await this.plugin.saveSettings();
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AskQuestionModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("obsidianrag-ask-modal");
    contentEl.createEl("h2", { text: "\u{1F916} Ask ObsidianRAG" });
    this.inputEl = contentEl.createEl("textarea", {
      placeholder: "Ask a question about your notes...",
      cls: "obsidianrag-modal-input"
    });
    const buttonContainer = contentEl.createDiv("modal-button-container");
    const askBtn = buttonContainer.createEl("button", { text: "Ask", cls: "mod-cta" });
    askBtn.addEventListener("click", () => this.askQuestion());
    const openChatBtn = buttonContainer.createEl("button", { text: "Open Full Chat" });
    openChatBtn.addEventListener("click", () => {
      this.close();
      this.plugin.activateChatView();
    });
    this.resultEl = contentEl.createDiv("obsidianrag-modal-result");
    this.inputEl.focus();
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.askQuestion();
      }
    });
  }
  async askQuestion() {
    const question = this.inputEl.value.trim();
    if (!question)
      return;
    if (!await this.plugin.isServerRunning()) {
      this.resultEl.setText("\u26A0\uFE0F Server is not running. Start it first.");
      return;
    }
    this.resultEl.empty();
    this.resultEl.createDiv({ text: "\u{1F504} Thinking...", cls: "loading" });
    try {
      let answer = "";
      for await (const event of this.plugin.askQuestionStreaming(question)) {
        if (event.type === "token") {
          answer += event.content;
        } else if (event.type === "answer") {
          answer = event.answer;
        } else if (event.type === "error") {
          this.resultEl.setText(`\u274C ${event.message}`);
          return;
        }
      }
      this.resultEl.empty();
      import_obsidian.MarkdownRenderer.render(
        this.app,
        answer,
        this.resultEl,
        "",
        this.plugin
      );
    } catch (error) {
      this.resultEl.setText(`\u274C Error: ${error}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ChatView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    // Status element reference for periodic updates
    this.statusEl = null;
    this.statusInterval = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CHAT;
  }
  getDisplayText() {
    return "ObsidianRAG Chat";
  }
  getIcon() {
    return "message-circle";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("obsidianrag-chat-container");
    const header = container.createDiv("obsidianrag-header");
    header.createEl("h4", { text: "\u{1F916} ObsidianRAG" });
    const headerControls = header.createDiv("obsidianrag-header-controls");
    const clearBtn = headerControls.createEl("button", {
      cls: "obsidianrag-clear-btn",
      attr: { "aria-label": "Clear chat history" }
    });
    clearBtn.innerHTML = "\u{1F5D1}\uFE0F";
    clearBtn.addEventListener("click", () => this.clearHistory());
    this.statusEl = headerControls.createSpan("obsidianrag-status");
    this.updateStatus();
    this.statusInterval = window.setInterval(() => this.updateStatus(), 5e3);
    this.containerEl_messages = container.createDiv("obsidianrag-messages");
    this.addMessage({
      role: "assistant",
      content: "Hello! I can answer questions about your notes. What would you like to know?",
      timestamp: /* @__PURE__ */ new Date()
    });
    const inputContainer = container.createDiv("obsidianrag-input-container");
    this.inputEl = inputContainer.createEl("textarea", {
      placeholder: "Ask a question about your notes...",
      cls: "obsidianrag-input"
    });
    const sendButton = inputContainer.createEl("button", {
      text: "Send",
      cls: "obsidianrag-send-button"
    });
    sendButton.addEventListener("click", () => this.sendMessage());
    this.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.sendMessage();
      }
    });
  }
  clearHistory() {
    this.messages = [];
    this.containerEl_messages.empty();
    this.addMessage({
      role: "assistant",
      content: "Chat history cleared. How can I help you?",
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  async updateStatus() {
    if (!this.statusEl)
      return;
    const running = await this.plugin.isServerRunning();
    this.statusEl.empty();
    this.statusEl.removeClass("status-online", "status-offline");
    if (running) {
      this.statusEl.addClass("status-online");
      this.statusEl.setText("\u25CF Online");
    } else {
      this.statusEl.addClass("status-offline");
      this.statusEl.setText("\u25CF Offline");
    }
  }
  async sendMessage() {
    const question = this.inputEl.value.trim();
    if (!question)
      return;
    this.addMessage({
      role: "user",
      content: question,
      timestamp: /* @__PURE__ */ new Date()
    });
    this.inputEl.value = "";
    if (!await this.plugin.isServerRunning()) {
      this.addMessage({
        role: "assistant",
        content: "\u26A0\uFE0F Server is not running. Use the command palette to start it, or enable auto-start in settings.",
        timestamp: /* @__PURE__ */ new Date()
      });
      return;
    }
    const progressEl = this.containerEl_messages.createDiv(
      "obsidianrag-message assistant loading"
    );
    const progressContent = progressEl.createDiv("progress-content");
    progressContent.innerHTML = "\u{1F504} <strong>Starting...</strong>";
    const updateProgress = (step, details) => {
      progressContent.innerHTML = `\u{1F504} <strong>${step}</strong>${details ? `<br><span class="progress-details">${details}</span>` : ""}`;
      this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;
    };
    let streamingEl = null;
    let streamingContent = "";
    let retrievedSources = [];
    let ttftLogged = false;
    try {
      let finalAnswer = null;
      for await (const event of this.plugin.askQuestionStreaming(question)) {
        switch (event.type) {
          case "start":
            updateProgress("Connecting...");
            break;
          case "status":
            updateProgress(event.message);
            break;
          case "retrieve_complete":
            retrievedSources = event.sources;
            updateProgress(
              `\u{1F4DA} Retrieved ${event.docs_count} documents`,
              event.sources.slice(0, 3).map(
                (s) => {
                  var _a;
                  return `\u2022 ${((_a = s.source.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || s.source}`;
                }
              ).join("<br>")
            );
            break;
          case "ttft":
            console.log(`\u26A1 [ObsidianRAG] Time to First Token: ${event.seconds}s`);
            ttftLogged = true;
            break;
          case "token":
            if (!streamingEl) {
              progressEl.remove();
              streamingEl = this.containerEl_messages.createDiv(
                "obsidianrag-message assistant streaming"
              );
              const contentDiv = streamingEl.createDiv("message-content");
              contentDiv.createDiv("streaming-text streaming-content");
            }
            streamingContent += event.content;
            const textEl = streamingEl.querySelector(".streaming-text");
            if (textEl) {
              textEl.empty();
              import_obsidian.MarkdownRenderer.render(
                this.app,
                streamingContent,
                textEl,
                "",
                this
              );
            }
            this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;
            break;
          case "generate_complete":
            if (!streamingEl) {
              updateProgress(
                "\u270D\uFE0F Generating answer...",
                event.answer_preview.substring(0, 100) + "..."
              );
            }
            break;
          case "answer":
            finalAnswer = event;
            break;
          case "error":
            progressEl.remove();
            if (streamingEl)
              streamingEl.remove();
            this.addMessage({
              role: "assistant",
              content: `\u274C Error: ${event.message}`,
              timestamp: /* @__PURE__ */ new Date()
            });
            return;
          case "done":
            break;
        }
      }
      if (progressEl.parentElement) {
        progressEl.remove();
      }
      if (finalAnswer) {
        const vaultPath = this.app.vault.adapter.basePath;
        const sourcesWithScores = [];
        for (const s of finalAnswer.sources || []) {
          let source = s.source;
          if (source.startsWith(vaultPath)) {
            source = source.substring(vaultPath.length);
            if (source.startsWith("/")) {
              source = source.substring(1);
            }
          }
          let displayPath = source;
          if (displayPath.endsWith(".md")) {
            displayPath = displayPath.substring(0, displayPath.length - 3);
          }
          const fileWithMd = source.endsWith(".md") ? source : source + ".md";
          const file = this.app.vault.getAbstractFileByPath(fileWithMd) || this.app.vault.getAbstractFileByPath(source);
          if (file) {
            sourcesWithScores.push({
              path: displayPath,
              displayName: displayPath.split("/").pop() || displayPath,
              score: s.score,
              exists: true
            });
          } else {
            const baseName = displayPath.split("/").pop() || displayPath;
            const allFiles = this.app.vault.getMarkdownFiles();
            const matchingFile = allFiles.find(
              (f) => f.basename.toLowerCase() === baseName.toLowerCase()
            );
            if (matchingFile) {
              const matchPath = matchingFile.path.endsWith(".md") ? matchingFile.path.substring(0, matchingFile.path.length - 3) : matchingFile.path;
              sourcesWithScores.push({
                path: matchPath,
                displayName: matchingFile.basename,
                score: s.score,
                exists: true
              });
            } else {
              console.log(`[ObsidianRAG] Skipping non-existent source: ${displayPath}`);
            }
          }
        }
        const seen = /* @__PURE__ */ new Set();
        const uniqueSorted = sourcesWithScores.filter((s) => s.exists !== false).sort((a, b) => b.score - a.score).filter((s) => {
          if (seen.has(s.path))
            return false;
          seen.add(s.path);
          return true;
        });
        if (streamingEl) {
          streamingEl.removeClass("streaming");
          const textEl = streamingEl.querySelector(".streaming-text");
          if (textEl) {
            textEl.removeClass("streaming-content");
            textEl.empty();
            import_obsidian.MarkdownRenderer.render(
              this.app,
              finalAnswer.answer,
              textEl,
              "",
              this
            );
          }
          if (uniqueSorted.length > 0 && this.plugin.settings.showSourceLinks) {
            const sourcesEl = streamingEl.createDiv("message-sources");
            sourcesEl.createEl("strong", { text: "Sources (by relevance): " });
            uniqueSorted.forEach((source, i) => {
              if (i > 0)
                sourcesEl.appendText(" ");
              const sourceContainer = sourcesEl.createSpan("source-item");
              const scoreIndicator = this.getScoreIndicator(source.score);
              sourceContainer.appendText(scoreIndicator);
              if (source.exists !== false) {
                const link = sourceContainer.createEl("a", {
                  text: source.displayName,
                  cls: "internal-link"
                });
                link.addEventListener("click", (e) => {
                  e.preventDefault();
                  this.app.workspace.openLinkText(source.path, "");
                });
              } else {
                sourceContainer.createSpan({
                  text: source.displayName,
                  cls: "source-not-found"
                });
              }
            });
          }
          this.messages.push({
            role: "assistant",
            content: finalAnswer.answer,
            sources: uniqueSorted,
            timestamp: /* @__PURE__ */ new Date()
          });
        } else {
          this.addMessage({
            role: "assistant",
            content: finalAnswer.answer,
            sources: uniqueSorted,
            timestamp: /* @__PURE__ */ new Date()
          });
        }
      }
    } catch (error) {
      progressEl.remove();
      this.addMessage({
        role: "assistant",
        content: `\u274C Error: ${error}`,
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  addMessage(message) {
    this.messages.push(message);
    const messageEl = this.containerEl_messages.createDiv(
      `obsidianrag-message ${message.role}`
    );
    const contentEl = messageEl.createDiv("message-content");
    import_obsidian.MarkdownRenderer.render(
      this.app,
      message.content,
      contentEl,
      "",
      this
    );
    if (message.sources && message.sources.length > 0 && this.plugin.settings.showSourceLinks) {
      const sourcesEl = messageEl.createDiv("message-sources");
      sourcesEl.createEl("strong", { text: "Sources (by relevance): " });
      message.sources.forEach((source, i) => {
        if (i > 0)
          sourcesEl.appendText(" ");
        const sourceContainer = sourcesEl.createSpan("source-item");
        const scoreIndicator = this.getScoreIndicator(source.score);
        sourceContainer.appendText(scoreIndicator);
        if (source.exists !== false) {
          const link = sourceContainer.createEl("a", {
            text: source.displayName,
            cls: "internal-link"
          });
          link.setAttribute("title", `Relevance: ${(source.score * 100).toFixed(1)}%`);
          link.addEventListener("click", (e) => {
            e.preventDefault();
            this.app.workspace.openLinkText(source.path, "");
          });
        } else {
          const span = sourceContainer.createSpan({
            text: source.displayName,
            cls: "source-not-found"
          });
          span.setAttribute("title", `File not found in vault`);
        }
      });
    }
    this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;
  }
  /**
   * Get an emoji indicator based on the relevance score
   */
  getScoreIndicator(score) {
    if (score >= 0.8)
      return "\u{1F7E2}";
    if (score >= 0.6)
      return "\u{1F7E1}";
    if (score >= 0.4)
      return "\u{1F7E0}";
    return "\u{1F534}";
  }
  async onClose() {
    if (this.statusInterval) {
      window.clearInterval(this.statusInterval);
      this.statusInterval = null;
    }
    this.statusEl = null;
  }
};
var ObsidianRAGSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.statusRefreshInterval = null;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "ObsidianRAG Settings" });
    this.renderServerStatus(containerEl);
    containerEl.createEl("h3", { text: "Configuration" });
    new import_obsidian.Setting(containerEl).setName("ObsidianRAG Command").setDesc("Path to obsidianrag-server script or command").addText(
      (text) => text.setPlaceholder("/usr/local/bin/obsidianrag-server").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
        this.plugin.settings.pythonPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Server Port").setDesc("Port for the backend API server").addText(
      (text) => text.setPlaceholder("8000").setValue(String(this.plugin.settings.serverPort)).onChange(async (value) => {
        const port = parseInt(value) || DEFAULT_PORT;
        this.plugin.settings.serverPort = port;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LLM Model").setDesc("Ollama model to use for answering questions").addDropdown(
      (dropdown) => dropdown.addOption("gemma3", "Gemma 3 (recommended)").addOption("llama3.2", "Llama 3.2").addOption("mistral", "Mistral").addOption("qwen2.5", "Qwen 2.5").addOption("phi3", "Phi 3").setValue(this.plugin.settings.llmModel).onChange(async (value) => {
        this.plugin.settings.llmModel = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "RAG Settings" });
    new import_obsidian.Setting(containerEl).setName("Use Reranker").setDesc("Enable CrossEncoder reranking for better relevance (slower but more accurate)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.useReranker).onChange(async (value) => {
        this.plugin.settings.useReranker = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-start Server").setDesc("Automatically start the backend when Obsidian opens").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoStartServer).onChange(async (value) => {
        this.plugin.settings.autoStartServer = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Source Links").setDesc("Display links to source notes in answers").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSourceLinks).onChange(async (value) => {
        this.plugin.settings.showSourceLinks = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Server Controls" });
    new import_obsidian.Setting(containerEl).setName("Start Server").setDesc("Manually start the backend server").addButton(
      (button) => button.setButtonText("Start").onClick(async () => {
        await this.plugin.startServer();
        this.display();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Stop Server").setDesc("Stop the backend server").addButton(
      (button) => button.setButtonText("Stop").onClick(async () => {
        await this.plugin.stopServer();
        this.display();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Reindex Vault").setDesc("Force reindex all notes in the vault").addButton(
      (button) => button.setButtonText("Reindex").setWarning().onClick(async () => {
        await this.plugin.reindexVault();
      })
    );
    this.renderVaultStats(containerEl);
    containerEl.createEl("h3", { text: "Requirements" });
    const helpEl = containerEl.createEl("div", { cls: "setting-item-description" });
    helpEl.innerHTML = `
      <p>This plugin requires:</p>
      <ul>
        <li><strong>Python 3.11+</strong> installed and accessible</li>
        <li><strong>obsidianrag</strong> package: <code>pip install obsidianrag</code></li>
        <li><strong>Ollama</strong> running locally with at least one model</li>
      </ul>
      <p>Install Ollama from <a href="https://ollama.ai">ollama.ai</a></p>
    `;
    containerEl.createEl("h3", { text: "Advanced" });
    new import_obsidian.Setting(containerEl).setName("Reset Setup Wizard").setDesc("Show the setup wizard again on next reload").addButton(
      (button) => button.setButtonText("Reset").onClick(async () => {
        this.plugin.settings.hasCompletedSetup = false;
        await this.plugin.saveSettings();
        new import_obsidian.Notice("Setup wizard will show on next reload");
      })
    );
  }
  async renderServerStatus(containerEl) {
    const statusContainer = containerEl.createDiv("obsidianrag-settings-status");
    statusContainer.createEl("h3", { text: "Server Status" });
    const statusEl = statusContainer.createDiv("status-display");
    const running = await this.plugin.isServerRunning();
    if (running) {
      statusEl.addClass("status-online");
      statusEl.innerHTML = `
        <span class="status-indicator">\u25CF</span>
        <span class="status-text">Server is running</span>
      `;
      try {
        const response = await fetch(`http://127.0.0.1:${this.plugin.settings.serverPort}/health`);
        if (response.ok) {
          const health = await response.json();
          statusEl.innerHTML += `
            <div class="status-details">
              <div>Version: ${health.version}</div>
              <div>Model: ${health.model}</div>
            </div>
          `;
        }
      } catch (e) {
      }
    } else {
      statusEl.addClass("status-offline");
      statusEl.innerHTML = `
        <span class="status-indicator">\u25CF</span>
        <span class="status-text">Server is offline</span>
      `;
    }
  }
  async renderVaultStats(containerEl) {
    containerEl.createEl("h3", { text: "Vault Statistics" });
    const statsContainer = containerEl.createDiv("obsidianrag-vault-stats");
    const running = await this.plugin.isServerRunning();
    if (!running) {
      statsContainer.setText("Start the server to view vault statistics.");
      return;
    }
    statsContainer.setText("Loading statistics...");
    const stats = await this.plugin.getStats();
    if (stats && !stats.error) {
      statsContainer.empty();
      const table = statsContainer.createEl("table", { cls: "stats-table" });
      const rows = [
        ["Total Notes", String(stats.total_notes)],
        ["Total Chunks", String(stats.total_chunks)],
        ["Total Words", String(stats.total_words).replace(/\B(?=(\d{3})+(?!\d))/g, ",")],
        ["Avg Words/Chunk", String(stats.avg_words_per_chunk)],
        ["Folders", String(stats.folders)],
        ["Internal Links", String(stats.internal_links)],
        ["Vault", stats.vault_path]
      ];
      rows.forEach(([label, value]) => {
        const row = table.createEl("tr");
        row.createEl("td", { text: label, cls: "stats-label" });
        row.createEl("td", { text: value, cls: "stats-value" });
      });
    } else {
      statsContainer.setText((stats == null ? void 0 : stats.error) || "Could not load statistics.");
    }
  }
  hide() {
    if (this.statusRefreshInterval) {
      window.clearInterval(this.statusRefreshInterval);
      this.statusRefreshInterval = null;
    }
  }
};
