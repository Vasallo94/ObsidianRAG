
> obsidian-rag@1.0.2 lint /Users/enriquebook/Personal/Developer/ObsidianRAG/plugin
> eslint src/ --format json

[{"filePath":"/Users/enriquebook/Personal/Developer/ObsidianRAG/plugin/src/main.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Invalid character.","line":308,"column":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ObsidianRAG Plugin\n * \n * Ask questions about your Obsidian notes using local AI.\n * Uses a Python backend (obsidianrag) with Ollama for LLM inference.\n */\n\nimport { exec, spawn } from \"child_process\";\nimport {\n    App,\n    ItemView,\n    MarkdownRenderer,\n    Modal,\n    Notice,\n    Plugin,\n    PluginSettingTab,\n    requestUrl,\n    RequestUrlParam,\n    Setting,\n    WorkspaceLeaf\n} from \"obsidian\";\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst VIEW_TYPE_CHAT = \"obsidianrag-chat-view\";\nconst DEFAULT_PORT = 8000;\nconst MAX_RETRY_ATTEMPTS = 3;\nconst RETRY_DELAY_MS = 1000;\n\n// ============================================================================\n// Interfaces\n// ============================================================================\n\ninterface ObsidianRAGSettings {\n  pythonPath: string;\n  serverPort: number;\n  llmModel: string;\n  autoStartServer: boolean;\n  showSourceLinks: boolean;\n  useReranker: boolean;\n  hasCompletedSetup: boolean;\n}\n\ninterface AskResponse {\n  result: string;\n  sources: Array<{ source: string; score: number; retrieval_type: string }>;\n  question: string;\n  process_time: number;\n  session_id: string;\n  error?: string;\n}\n\ninterface HealthResponse {\n  status: string;\n  version: string;\n  model: string;\n}\n\ninterface SourceInfo {\n  path: string;\n  displayName: string;\n  score: number;\n  exists?: boolean;  // Whether the file exists in vault\n}\n\ninterface ChatMessage {\n  role: \"user\" | \"assistant\";\n  content: string;\n  sources?: SourceInfo[];\n  timestamp: Date;\n}\n\n// Streaming event types\ninterface StreamEventStart {\n  type: \"start\";\n  session_id: string;\n}\n\ninterface StreamEventStatus {\n  type: \"status\";\n  message: string;\n}\n\ninterface StreamEventRetrieve {\n  type: \"retrieve_complete\";\n  docs_count: number;\n  sources: Array<{ source: string; score: number }>;\n}\n\ninterface StreamEventToken {\n  type: \"token\";\n  content: string;\n}\n\ninterface StreamEventGenerate {\n  type: \"generate_complete\";\n  answer_preview: string;\n}\n\ninterface StreamEventTTFT {\n  type: \"ttft\";\n  seconds: number;\n}\n\ninterface StreamEventAnswer {\n  type: \"answer\";\n  question: string;\n  answer: string;\n  sources: Array<{ source: string; score: number; retrieval_type: string }>;\n  process_time: number;\n}\n\ninterface StreamEventError {\n  type: \"error\";\n  message: string;\n}\n\ninterface StreamEventDone {\n  type: \"done\";\n}\n\ntype StreamEvent =\n  | StreamEventStart\n  | StreamEventStatus\n  | StreamEventRetrieve\n  | StreamEventToken\n  | StreamEventTTFT\n  | StreamEventGenerate\n  | StreamEventAnswer\n  | StreamEventError\n  | StreamEventDone;\n\n// ============================================================================\n// Default Settings\n// ============================================================================\n\nconst DEFAULT_SETTINGS: ObsidianRAGSettings = {\n  pythonPath: \"/usr/local/bin/obsidianrag-server\",\n  serverPort: DEFAULT_PORT,\n  llmModel: \"gemma3\",\n  autoStartServer: true,\n  showSourceLinks: true,\n  useReranker: true,\n  hasCompletedSetup: false,\n};\n\n// ============================================================================\n// Stats Response Interface\n// ============================================================================\n\ninterface StatsResponse {\n  total_notes: number;\n  total_chunks: number;\n  total_words: number;\n  total_chars: number;\n  avg_words_per_chunk: number;\n  folders: number;\n  internal_links: number;\n  vault_path: string;\n  error?: string;\n}\n\n// ============================================================================\n// Ollama Models Interface\n// ============================================================================\n\ninterface OllamaModel {\n  name: string;\n  modified_at: string;\n  size: number;\n}\n\ninterface OllamaModelsResponse {\n  models: OllamaModel[];\n}\n\n// ============================================================================\n// Main Plugin Class\n// ============================================================================\n\nexport default class ObsidianRAGPlugin extends Plugin {\n  settings!: ObsidianRAGSettings;\n  private serverProcess: ReturnType<typeof spawn> | null = null;\n  private apiBaseUrl: string = \"\";\n  private restartAttempts: number = 0;\n  private maxRestartAttempts: number = 3;\n  private isRestarting: boolean = false;\n  statusBarItem: HTMLElement | null = null;\n\n  async onload() {\n    console.debug(\"Loading ObsidianRAG plugin\");\n\n    await this.loadSettings();\n    this.apiBaseUrl = `http://127.0.0.1:${this.settings.serverPort}`;\n\n    // Register the chat view\n    this.registerView(VIEW_TYPE_CHAT, (leaf) => new ChatView(leaf, this));\n\n    // Add ribbon icon\n    this.addRibbonIcon(\"message-circle\", \"Chat\", () => {\n      void this.activateChatView();\n    });\n\n    // Add status bar item\n    this.statusBarItem = this.addStatusBarItem();\n    this.statusBarItem.addClass(\"obsidianrag-status-bar\");\n    void this.updateStatusBar();\n\n    // Add commands\n    this.addCommand({\n      id: \"open-chat\",\n      name: \"Open chat\",\n      callback: () => { void this.activateChatView(); },\n    });\n\n    this.addCommand({\n      id: \"start-server\",\n      name: \"Start server\",\n      callback: () => { void this.startServer(); },\n    });\n\n    this.addCommand({\n      id: \"stop-server\",\n      name: \"Stop server\",\n      callback: () => { void this.stopServer(); },\n    });\n\n    this.addCommand({\n      id: \"check-status\",\n      name: \"Check status\",\n      callback: () => { void this.checkServerStatus(); },\n    });\n\n    this.addCommand({\n      id: \"ask-question\",\n      name: \"Ask a question\",\n      callback: () => new AskQuestionModal(this.app, this).open(),\n    });\n\n    this.addCommand({\n      id: \"reindex-vault\",\n      name: \"Reindex vault\",\n      callback: () => { void this.reindexVault(); },\n    });\n\n    // Add settings tab\n    this.addSettingTab(new ObsidianRAGSettingTab(this.app, this));\n\n    // Show setup modal on first run\n    if (!this.settings.hasCompletedSetup) {\n      new SetupModal(this.app, this).open();\n    }\n\n    // Auto-start server if enabled\n    if (this.settings.autoStartServer) {\n      // Small delay to let Obsidian finish loading\n      setTimeout(() => { void this.startServer(); }, 2000);\n    }\n\n    // Start status bar update interval\n    this.registerInterval(\n      window.setInterval(() => { void this.updateStatusBar(); }, 10000)\n    );\n  }\n\n  onunload(): void {\n    console.debug(\"Unloading ObsidianRAG plugin\");\n    void this.stopServer();\n  }\n\n  async loadSettings() {\n    this.settings = Object.assign({}, DEFAULT_SETTINGS, (await this.loadData()) as ObsidianRAGSettings);\n  }\n\n  async saveSettings() {\n    await this.saveData(this.settings);\n    this.apiBaseUrl = `http://127.0.0.1:${this.settings.serverPort}`;\n  }\n\n  // ==========================================================================\n  // Status Bar\n  // ==========================================================================\n\n  async updateStatusBar() {\n    if (!this.statusBarItem) return;\n    \n    const running = await this.isServerRunning();\n    this.statusBarItem.empty();\n    \n    if (running) {\n      this.statusBarItem.setText(\"ðŸ¤– RAG â—\");\n      this.statusBarItem.setAttribute(\"title\", \"Vault RAG: Online - Click to open chat\");\n      this.statusBarItem.addClass(\"status-online\");\n      this.statusBarItem.removeClass(\"status-offline\");\n    } else {\n      this.statusBarItem.setText(\"ðŸ¤– RAG â—‹\");\n      this.statusBarItem.setAttribute(\"title\", \"Vault RAG: Offline - Click to start server\");\n      this.statusBarItem.addClass(\"status-offline\");\n      this.statusBarItem.removeClass(\"status-online\");\n    }\n    \n    // Make status bar clickable\n    this.statusBarItem.onClickEvent(() => {\n      if (running) {\n        void this.activateChatView();\n      } else {\\n        void this.startServer();\n      }\n    });\n  }\n\n  // ==========================================================================\n  // View Management\n  // ==========================================================================\n\n  async activateChatView() {\n    const { workspace } = this.app;\n\n    let leaf = workspace.getLeavesOfType(VIEW_TYPE_CHAT)[0];\n\n    if (!leaf) {\n      const rightLeaf = workspace.getRightLeaf(false);\n      if (rightLeaf) {\n        leaf = rightLeaf;\n        await leaf.setViewState({ type: VIEW_TYPE_CHAT, active: true });\n      }\n    }\n\n    if (leaf) {\n      workspace.revealLeaf(leaf);\n    }\n  }\n\n  // ==========================================================================\n  // Server Management\n  // ==========================================================================\n\n  async startServer(): Promise<boolean> {\n    // First check if already running\n    if (await this.isServerRunning()) {\n      new Notice(\"Vault RAG server is already running\");\n      return true;\n    }\n\n    new Notice(\"Starting Vault RAG server...\");\n\n    try {\n      const vaultPath = (this.app.vault.adapter as { basePath: string }).basePath;\n      const platform = process.platform;\n\n      // Get platform-specific spawn options\n      const spawnOptions = this.getSpawnOptionsForPlatform(platform);\n\n      // Prepare the command based on platform\n      let command: string;\n      let args: string[];\n\n      if (platform === 'win32') {\n        // On Windows, we need to use shell and handle paths differently\n        command = this.settings.pythonPath;\n        args = [\n          \"serve\",\n          \"--vault\",\n          `\"${vaultPath}\"`, // Quote path for Windows\n          \"--port\",\n          String(this.settings.serverPort),\n          \"--model\",\n          this.settings.llmModel,\n          this.settings.useReranker ? \"--reranker\" : \"--no-reranker\",\n        ];\n      } else {\n        // macOS and Linux\n        command = this.settings.pythonPath;\n        args = [\n          \"serve\",\n          \"--vault\",\n          vaultPath,\n          \"--port\",\n          String(this.settings.serverPort),\n          \"--model\",\n          this.settings.llmModel,\n          this.settings.useReranker ? \"--reranker\" : \"--no-reranker\",\n        ];\n      }\n\n      this.serverProcess = spawn(command, args, spawnOptions);\n\n      this.serverProcess.stdout?.on(\"data\", (data: Buffer) => {\n        console.debug(`[ObsidianRAG] ${data.toString()}`);\n      });\n\n      this.serverProcess.stderr?.on(\"data\", (data: Buffer) => {\n        console.error(`[ObsidianRAG] ${data.toString()}`);\n      });\n\n      this.serverProcess.on(\"error\", (error: Error) => {\n        console.error(\"[ObsidianRAG] Process error:\", error);\n        new Notice(`Failed to start server: ${error.message}`);\n      });\n\n      this.serverProcess.on(\"exit\", (code: number) => {\n        console.debug(`[ObsidianRAG] Server exited with code ${code}`);\n        this.serverProcess = null;\n        // Auto-restart if enabled and not manually stopped\n        if (this.settings.autoStartServer && !this.isRestarting) {\n          this.handleServerCrash(code);\n        }\n      });\n\n      // Wait for server to be ready\n      const ready = await this.waitForServer(30000);\n      if (ready) {\n        this.restartAttempts = 0; // Reset on successful start\n        new Notice(\"Vault RAG server started successfully!\");\n        this.updateStatusBar();\n        return true;\n      } else {\n        new Notice(\"Server started but not responding. Check logs.\");\n        return false;\n      }\n    } catch (error) {\n      console.error(\"[ObsidianRAG] Failed to start server:\", error);\n      new Notice(`Failed to start server: ${error}`);\n      return false;\n    }\n  }\n\n  private async handleServerCrash(exitCode: number): Promise<void> {\n    if (this.restartAttempts >= this.maxRestartAttempts) {\n      new Notice(`Server crashed ${this.maxRestartAttempts} times. Please check logs and restart manually.`);\n      this.restartAttempts = 0;\n      return;\n    }\n\n    this.restartAttempts++;\n    this.isRestarting = true;\n    \n    const delay = RETRY_DELAY_MS * this.restartAttempts; // Exponential backoff\n    new Notice(`Server exited with code ${exitCode}. Restarting in ${delay/1000}s... (attempt ${this.restartAttempts}/${this.maxRestartAttempts})`);\n    \n    await new Promise(resolve => setTimeout(resolve, delay));\n    \n    this.isRestarting = false;\n    await this.startServer();\n  }\n\n  async stopServer(): Promise<void> {\n    this.isRestarting = true; // Prevent auto-restart\n    \n    // First, try to kill the tracked process\n    if (this.serverProcess) {\n      this.serverProcess.kill();\n      this.serverProcess = null;\n    }\n    \n    // Also try to kill any process on the port (in case server was started externally)\n    try {\n      const platform = process.platform;\n      \n      const killCmd = platform === 'win32' \n        ? `for /f \"tokens=5\" %a in ('netstat -aon ^| find \":${this.settings.serverPort}\" ^| find \"LISTENING\"') do taskkill /F /PID %a`\n        : `lsof -ti:${this.settings.serverPort} | xargs kill -9 2>/dev/null`;\n\n      await new Promise<void>((resolve) => {\n        exec(killCmd, (error: Error | null) => {\n          if (error) console.debug(\"[ObsidianRAG] No process found on port\");\n          resolve();\n        });\n      });\n    } catch (e) {\n      console.debug(\"[ObsidianRAG] Could not kill process by port:\", e);\n    }\n    \n    new Notice(\"Vault RAG server stopped\");\n    this.isRestarting = false;\n    this.updateStatusBar();\n  }\n\n  async isServerRunning(): Promise<boolean> {\n    try {\n      const response = await requestUrl({\n        url: `${this.apiBaseUrl}/health`,\n        method: \"GET\",\n      });\n      return response.status >= 200 && response.status < 300;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Fetch available models from Ollama\n   */\n  async getOllamaModels(): Promise<string[]> {\n    try {\n      const response = await requestUrl({\n        url: \"http://localhost:11434/api/tags\",\n        method: \"GET\",\n      });\n      \n      if (response.status < 200 || response.status >= 300) {\n        console.warn(\"[ObsidianRAG] Failed to fetch Ollama models\");\n        return [];\n      }\n      \n      const data: OllamaModelsResponse = response.json;\n      // Extract model names (remove :latest suffix for cleaner display)\n      return data.models.map(m => m.name.replace(\":latest\", \"\"));\n    } catch (error) {\n      console.warn(\"[ObsidianRAG] Ollama not available:\", error);\n      return [];\n    }\n  }\n\n  private async waitForServer(timeout: number): Promise<boolean> {\n    const start = Date.now();\n    while (Date.now() - start < timeout) {\n      if (await this.isServerRunning()) {\n        return true;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    }\n    return false;\n  }\n\n  async checkServerStatus(): Promise<void> {\n    try {\n      const response = await requestUrl(`${this.apiBaseUrl}/health`);\n      if (response.status >= 200 && response.status < 300) {\n        const data: HealthResponse = response.json;\n        new Notice(\n          `Server OK\\nVersion: ${data.version}\\nModel: ${data.model}`\n        );\n      } else {\n        new Notice(\"Server responded but with an error\");\n      }\n    } catch {\n      new Notice(\"Server is not running\");\n    }\n  }\n\n  // ==========================================================================\n  // API Methods\n  // ==========================================================================\n\n  async askQuestion(question: string): Promise<AskResponse> {\n    try {\n      const response = await requestUrl({\n        url: `${this.apiBaseUrl}/ask`,\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ text: question }),\n      });\n\n      if (response.status < 200 || response.status >= 300) {\n        throw new Error(`Server error: ${response.status}`);\n      }\n\n      return response.json;\n    } catch (error) {\n      return {\n        result: \"\",\n        sources: [],\n        question: \"\",\n        process_time: 0,\n        session_id: \"\",\n        error: `Failed to get answer: ${error}`,\n      };\n    }\n  }\n\n  /**\n   * Ask a question with streaming-like events using Obsidian's requestUrl\n   * Note: True streaming is not supported by requestUrl, so we simulate events\n   */\n  async *askQuestionStreaming(\n    question: string\n  ): AsyncGenerator<StreamEvent, void, unknown> {\n    try {\n      // Emit start event\n      yield { type: \"start\", session_id: \"\" };\n      yield { type: \"status\", message: \"Sending question...\" };\n\n      const response = await requestUrl({\n        url: `${this.apiBaseUrl}/ask`,\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ text: question }),\n      });\n\n      if (response.status < 200 || response.status >= 300) {\n        yield { type: \"error\", message: `Server error: ${response.status}` };\n        return;\n      }\n\n      const data = response.json as AskResponse;\n      \n      if (data.error) {\n        yield { type: \"error\", message: data.error };\n        return;\n      }\n\n      // Emit retrieve complete event\n      yield { \n        type: \"retrieve_complete\", \n        docs_count: data.sources?.length || 0,\n        sources: data.sources?.map(s => ({ source: s.source, score: s.score })) || []\n      };\n\n      // Simulate token streaming by yielding the full answer\n      // This maintains compatibility with the UI that expects tokens\n      yield { type: \"token\", content: data.result };\n\n      // Emit final answer event\n      yield { \n        type: \"answer\", \n        question: data.question,\n        answer: data.result,\n        sources: data.sources || [],\n        process_time: data.process_time\n      };\n\n      yield { type: \"done\" };\n    } catch (error) {\n      yield { type: \"error\", message: `Request error: ${error}` };\n    }\n  }\n\n  /**\n   * Get vault statistics from the server\n   */\n  async getStats(): Promise<StatsResponse | null> {\n    return await this.fetchWithRetry<StatsResponse>(`${this.apiBaseUrl}/stats`);\n  }\n\n  /**\n   * Trigger vault reindexing\n   */\n  async reindexVault(): Promise<boolean> {\n    if (!(await this.isServerRunning())) {\n      new Notice(\"Server is not running. Start it first.\");\n      return false;\n    }\n\n    new Notice(\"Reindexing vault... This may take a while.\");\n    \n    try {\n      const response = await requestUrl({\n        url: `${this.apiBaseUrl}/rebuild_db`,\n        method: \"POST\",\n      });\n\n      if (response.status >= 200 && response.status < 300) {\n        const data = response.json;\n        new Notice(`Reindexing complete! Indexed ${data.total_chunks || 'unknown'} chunks.`);\n        return true;\n      } else {\n        new Notice(`Reindexing failed: ${response.status}`);\n        return false;\n      }\n    } catch (error) {\n      new Notice(`Reindexing failed: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Fetch with retry logic\n   */\n  private async fetchWithRetry<T>(\n    url: string,\n    options: Omit<RequestUrlParam, \"url\"> = {},\n    attempts: number = MAX_RETRY_ATTEMPTS\n  ): Promise<T | null> {\n    let lastError: Error | null = null;\n\n    for (let i = 0; i < attempts; i++) {\n      try {\n        const response = await requestUrl({\n          url,\n          ...options,\n        });\n\n        if (response.status >= 200 && response.status < 300) {\n          return response.json;\n        }\n        \n        lastError = new Error(`HTTP ${response.status}`);\n      } catch (error) {\n        lastError = error as Error;\n        // Wait before retry with exponential backoff\n        if (i < attempts - 1) {\n          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * (i + 1)));\n        }\n      }\n    }\n\n    console.error(`[ObsidianRAG] Failed after ${attempts} attempts:`, lastError);\n    return null;\n  }\n\n  /**\n   * Get platform-specific spawn options\n   */\n  getSpawnOptionsForPlatform(platform: string): { \n    shell: boolean; \n    env: NodeJS.ProcessEnv;\n    windowsHide?: boolean;\n  } {\n    const env = { \n      ...process.env, \n      OBSIDIANRAG_LLM_MODEL: this.settings.llmModel,\n      OBSIDIANRAG_USE_RERANKER: this.settings.useReranker ? \"true\" : \"false\",\n    };\n\n    if (platform === 'win32') {\n      // Windows: use shell for proper command resolution, hide console window\n      return { \n        shell: true, \n        env,\n        windowsHide: true,\n      };\n    } else if (platform === 'linux') {\n      // Linux: similar to macOS but may need different shell handling\n      return { \n        shell: false, \n        env,\n      };\n    } else {\n      // macOS and others\n      return { \n        shell: false, \n        env,\n      };\n    }\n  }\n\n  /**\n   * Get default Python command based on platform\n   */\n  getDefaultPythonCommand(): string {\n    const platform = process.platform;\n    \n    if (platform === 'win32') {\n      // Windows: try py launcher first, then python\n      return 'py -m obsidianrag';\n    } else if (platform === 'linux') {\n      // Linux: usually python3\n      return 'python3 -m obsidianrag';\n    } else {\n      // macOS: could be python3 or the obsidianrag-server wrapper\n      return '/usr/local/bin/obsidianrag-server';\n    }\n  }\n}\n\n// ============================================================================\n// Modals\n// ============================================================================\n\n/**\n * Setup Modal - First-time setup wizard\n */\nclass SetupModal extends Modal {\n  plugin: ObsidianRAGPlugin;\n  private currentStep: number = 0;\n  private contentEl_modal!: HTMLElement;\n  private availableModels: string[] = [];\n\n  constructor(app: App, plugin: ObsidianRAGPlugin) {\n    super(app);\n    this.plugin = plugin;\n  }\n\n  async onOpen() {\n    const { contentEl } = this;\n    contentEl.empty();\n    contentEl.addClass(\"obsidianrag-setup-modal\");\n\n    new Setting(contentEl).setName(\"Welcome to Vault RAG\").setHeading();\n\n    // Fetch available models\n    this.availableModels = await this.plugin.getOllamaModels();\n\n    this.contentEl_modal = contentEl.createDiv(\"setup-content\");\n    this.showStep(0);\n  }\n\n  showStep(step: number) {\n    this.currentStep = step;\n    this.contentEl_modal.empty();\n\n    const steps = [\n      this.renderRequirements.bind(this),\n      this.renderConfiguration.bind(this),\n      this.renderComplete.bind(this),\n    ];\n\n    if (step < steps.length) {\n      steps[step]();\n    }\n  }\n\n  renderRequirements() {\n    const el = this.contentEl_modal;\n    \n    new Setting(el).setName(\"Check requirements\").setHeading();\n    \n    const requirements = el.createEl(\"ul\");\n    const li1 = requirements.createEl(\"li\");\n    li1.createEl(\"strong\", { text: \"Python 3.11+\" });\n    li1.appendText(\" - Required for the backend\");\n\n    const li2 = requirements.createEl(\"li\");\n    li2.createEl(\"strong\", { text: \"obsidianrag\" });\n    li2.appendText(\" package - \");\n    li2.createEl(\"code\", { text: \"pip install obsidianrag\" });\n\n    const li3 = requirements.createEl(\"li\");\n    li3.createEl(\"strong\", { text: \"Ollama\" });\n    li3.appendText(\" - Local LLM server from \");\n    li3.createEl(\"a\", { text: \"ollama.ai\", href: \"https://ollama.ai\" });\n\n    const li4 = requirements.createEl(\"li\");\n    li4.appendText(\"At least one Ollama model - \");\n    li4.createEl(\"code\", { text: \"ollama pull gemma3\" });\n\n    el.createEl(\"p\", { \n      text: \"Make sure you have all requirements installed before proceeding.\",\n      cls: \"setting-item-description\"\n    });\n\n    const buttons = el.createDiv(\"modal-button-container\");\n    \n    const nextBtn = buttons.createEl(\"button\", { text: \"Next â†’\", cls: \"mod-cta\" });\n    nextBtn.addEventListener(\"click\", () => this.showStep(1));\n\n    const skipBtn = buttons.createEl(\"button\", { text: \"Skip setup\" });\n    skipBtn.addEventListener(\"click\", () => this.completeSetup());\n  }\n\n  renderConfiguration() {\n    const el = this.contentEl_modal;\n    \n    new Setting(el).setName(\"Configuration\").setHeading();\n\n    // Server command\n    new Setting(el)\n      .setName(\"Backend command\")\n      .setDesc(\"Path to obsidianrag-server or 'obsidianrag' if installed globally\")\n      .addText(text => text\n        .setValue(this.plugin.settings.pythonPath)\n        .onChange(async (value) => {\n          this.plugin.settings.pythonPath = value;\n          await this.plugin.saveSettings();\n        }));\n\n    // Port\n    new Setting(el)\n      .setName(\"Server port\")\n      .addText(text => text\n        .setValue(String(this.plugin.settings.serverPort))\n        .onChange(async (value) => {\n          this.plugin.settings.serverPort = parseInt(value) || DEFAULT_PORT;\n          await this.plugin.saveSettings();\n        }));\n\n    // Model - populated from Ollama\n    const modelSetting = new Setting(el)\n      .setName(\"LLM model\");\n    \n    if (this.availableModels.length > 0) {\n      modelSetting.addDropdown(dropdown => {\n        this.availableModels.forEach(model => {\n          dropdown.addOption(model, model);\n        });\n        \n        // Set current value, or first available if current not in list\n        const currentModel = this.plugin.settings.llmModel;\n        if (this.availableModels.includes(currentModel)) {\n          dropdown.setValue(currentModel);\n        } else if (this.availableModels.length > 0) {\n          dropdown.setValue(this.availableModels[0]);\n          this.plugin.settings.llmModel = this.availableModels[0];\n          void this.plugin.saveSettings();\n        }\n        \n        dropdown.onChange(async (value) => {\n          this.plugin.settings.llmModel = value;\n          await this.plugin.saveSettings();\n        });\n      });\n    } else {\n      modelSetting\n        .setDesc(\"âš ï¸ Ollama not detected. Make sure Ollama is running.\")\n        .addText(text => text\n          .setPlaceholder(\"gemma3\")\n          .setValue(this.plugin.settings.llmModel)\n          .onChange(async (value) => {\n            this.plugin.settings.llmModel = value;\n            await this.plugin.saveSettings();\n          }));\n    }\n\n    // Auto-start\n    new Setting(el)\n      .setName(\"Auto-start server\")\n      .setDesc(\"Start the backend automatically when Obsidian opens\")\n      .addToggle(toggle => toggle\n        .setValue(this.plugin.settings.autoStartServer)\n        .onChange(async (value) => {\n          this.plugin.settings.autoStartServer = value;\n          await this.plugin.saveSettings();\n        }));\n\n    const buttons = el.createDiv(\"modal-button-container\");\n    \n    const backBtn = buttons.createEl(\"button\", { text: \"â† Back\" });\n    backBtn.addEventListener(\"click\", () => this.showStep(0));\n\n    const nextBtn = buttons.createEl(\"button\", { text: \"Finish â†’\", cls: \"mod-cta\" });\n    nextBtn.addEventListener(\"click\", () => this.showStep(2));\n  }\n\n  renderComplete() {\n    const el = this.contentEl_modal;\n    \n    new Setting(el).setName(\"Setup complete\").setHeading();\n    el.createEl(\"p\", { text: \"You're all set to use Vault RAG.\" });\n\n    const tips = el.createEl(\"ul\");\n    tips.createEl(\"li\", { text: \"Click the ðŸ¤– icon in the ribbon to open the chat\" });\n    tips.createEl(\"li\", { text: \"Use Cmd/Ctrl+P and search 'ObsidianRAG' for all commands\" });\n    tips.createEl(\"li\", { text: \"First question may take a moment while the vault is indexed\" });\n\n    const buttons = el.createDiv(\"modal-button-container\");\n    \n    const startBtn = buttons.createEl(\"button\", { text: \"Start server & open chat\", cls: \"mod-cta\" });\n    startBtn.addEventListener(\"click\", async () => {\n      await this.plugin.startServer();\n      void this.completeSetup();\n      void this.plugin.activateChatView();\n    });\n\n    const laterBtn = buttons.createEl(\"button\", { text: \"Maybe later\" });\n    laterBtn.addEventListener(\"click\", () => { void this.completeSetup(); });\n  }\n\n  async completeSetup() {\n    this.plugin.settings.hasCompletedSetup = true;\n    await this.plugin.saveSettings();\n    this.close();\n  }\n\n  onClose() {\n    const { contentEl } = this;\n    contentEl.empty();\n  }\n}\n\n/**\n * Ask Question Modal - Quick question from command palette\n */\nclass AskQuestionModal extends Modal {\n  plugin: ObsidianRAGPlugin;\n  private inputEl!: HTMLTextAreaElement;\n  private resultEl!: HTMLElement;\n\n  constructor(app: App, plugin: ObsidianRAGPlugin) {\n    super(app);\n    this.plugin = plugin;\n  }\n\n  onOpen() {\n    const { contentEl } = this;\n    contentEl.empty();\n    contentEl.addClass(\"obsidianrag-ask-modal\");\n\n    new Setting(contentEl).setName(\"Ask Vault RAG\").setHeading();\n\n    // Input\n    this.inputEl = contentEl.createEl(\"textarea\", {\n      placeholder: \"Ask a question about your notes...\",\n      cls: \"obsidianrag-modal-input\"\n    });\n\n    // Buttons\n    const buttonContainer = contentEl.createDiv(\"modal-button-container\");\n    \n    const askBtn = buttonContainer.createEl(\"button\", { text: \"Ask\", cls: \"mod-cta\" });\n    askBtn.addEventListener(\"click\", () => { void this.askQuestion(); });\n\n    const openChatBtn = buttonContainer.createEl(\"button\", { text: \"Open full chat\" });\n    openChatBtn.addEventListener(\"click\", () => {\n      this.close();\n      void this.plugin.activateChatView();\n    });\n\n    // Result area\n    this.resultEl = contentEl.createDiv(\"obsidianrag-modal-result\");\n\n    // Focus input\n    this.inputEl.focus();\n\n    // Enter to submit\n    this.inputEl.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        this.askQuestion();\n      }\n    });\n  }\n\n  async askQuestion() {\n    const question = this.inputEl.value.trim();\n    if (!question) return;\n\n    if (!(await this.plugin.isServerRunning())) {\n      this.resultEl.setText(\"âš ï¸ Server is not running. Start it first.\");\n      return;\n    }\n\n    this.resultEl.empty();\n    this.resultEl.createDiv({ text: \"ðŸ”„ Thinking...\", cls: \"loading\" });\n\n    try {\n      let answer = \"\";\n      for await (const event of this.plugin.askQuestionStreaming(question)) {\n        if (event.type === \"token\") {\n          answer += event.content;\n        } else if (event.type === \"answer\") {\n          answer = event.answer;\n        } else if (event.type === \"error\") {\n          this.resultEl.setText(`âŒ ${event.message}`);\n          return;\n        }\n      }\n\n      this.resultEl.empty();\n      void MarkdownRenderer.render(\n        this.app,\n        answer,\n        this.resultEl,\n        \"\",\n        this\n      );\n    } catch (error) {\n      this.resultEl.setText(`âŒ Error: ${error}`);\n    }\n  }\n\n  onClose() {\n    const { contentEl } = this;\n    contentEl.empty();\n  }\n}\n\n\n\n// ============================================================================\n// Chat View\n// ============================================================================\n\nclass ChatView extends ItemView {\n  plugin: ObsidianRAGPlugin;\n  messages: ChatMessage[] = [];\n  private containerEl_messages!: HTMLElement;\n  private inputEl!: HTMLTextAreaElement;\n\n  // Status element reference for periodic updates\n  private statusEl: HTMLElement | null = null;\n  private statusInterval: number | null = null;\n\n  constructor(leaf: WorkspaceLeaf, plugin: ObsidianRAGPlugin) {\n    super(leaf);\n    this.plugin = plugin;\n  }\n\n  getViewType(): string {\n    return VIEW_TYPE_CHAT;\n  }\n\n  getDisplayText(): string {\n    return \"Vault RAG\";\n  }\n\n  getIcon(): string {\n    return \"message-circle\";\n  }\n\n  async onOpen() {\n    const container = this.containerEl.children[1] as HTMLElement;\n    container.empty();\n    container.addClass(\"obsidianrag-chat-container\");\n\n    // Header\n    const header = container.createDiv(\"obsidianrag-header\");\n    header.createEl(\"span\", { text: \"Vault RAG\", cls: \"obsidianrag-header-title\" });\n\n    // Header controls\n    const headerControls = header.createDiv(\"obsidianrag-header-controls\");\n\n    // Reindex button\n    const reindexBtn = headerControls.createEl(\"button\", {\n      cls: \"obsidianrag-header-btn\",\n      attr: { \"aria-label\": \"Reindex vault\" }\n    });\n    reindexBtn.setText(\"ðŸ”„\");\n    reindexBtn.addEventListener(\"click\", async () => {\n      await this.plugin.reindexVault();\n    });\n\n    // Clear history button\n    const clearBtn = headerControls.createEl(\"button\", {\n      cls: \"obsidianrag-header-btn\",\n      attr: { \"aria-label\": \"Clear chat history\" }\n    });\n    clearBtn.setText(\"ðŸ—‘ï¸\");\n    clearBtn.addEventListener(\"click\", () => this.clearHistory());\n\n    // Status indicator\n    this.statusEl = headerControls.createSpan(\"obsidianrag-status\");\n    await this.updateStatus();\n\n    // Start periodic status check (every 5 seconds)\n    this.statusInterval = window.setInterval(() => this.updateStatus(), 5000);\n\n    // Messages container\n    this.containerEl_messages = container.createDiv(\"obsidianrag-messages\");\n\n    // Welcome message\n    this.addMessage({\n      role: \"assistant\",\n      content:\n        \"Hello! I can answer questions about your notes. What would you like to know?\",\n      timestamp: new Date(),\n    });\n\n    // Input container\n    const inputContainer = container.createDiv(\"obsidianrag-input-container\");\n\n    this.inputEl = inputContainer.createEl(\"textarea\", {\n      placeholder: \"Ask a question about your notes...\",\n      cls: \"obsidianrag-input\",\n    });\n\n    const sendButton = inputContainer.createEl(\"button\", {\n      text: \"Send\",\n      cls: \"obsidianrag-send-button\",\n    });\n\n    // Event handlers\n    sendButton.addEventListener(\"click\", () => this.sendMessage());\n\n    this.inputEl.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        this.sendMessage();\n      }\n    });\n  }\n\n  clearHistory() {\n    this.messages = [];\n    this.containerEl_messages.empty();\n    this.addMessage({\n      role: \"assistant\",\n      content: \"Chat history cleared. How can I help you?\",\n      timestamp: new Date(),\n    });\n  }\n\n  async updateStatus() {\n    if (!this.statusEl) return;\n    \n    const running = await this.plugin.isServerRunning();\n    this.statusEl.empty();\n    this.statusEl.removeClass(\"status-online\", \"status-offline\");\n    \n    if (running) {\n      this.statusEl.addClass(\"status-online\");\n      this.statusEl.setText(\"â— online\");\n    } else {\n      this.statusEl.addClass(\"status-offline\");\n      this.statusEl.setText(\"â— offline\");\n    }\n  }\n\n  async sendMessage() {\n    const question = this.inputEl.value.trim();\n    if (!question) return;\n\n    // Add user message\n    this.addMessage({\n      role: \"user\",\n      content: question,\n      timestamp: new Date(),\n    });\n\n    this.inputEl.value = \"\";\n\n    // Check if server is running\n    if (!(await this.plugin.isServerRunning())) {\n      this.addMessage({\n        role: \"assistant\",\n        content:\n          \"âš ï¸ Server is not running. Use the command palette to start it, or enable auto-start in settings.\",\n        timestamp: new Date(),\n      });\n      return;\n    }\n\n    // Show progress element\n    const progressEl = this.containerEl_messages.createDiv(\n      \"obsidianrag-message assistant loading\"\n    );\n    const progressContent = progressEl.createDiv(\"progress-content\");\n    progressContent.setText(\"ðŸ”„ \");\n    progressContent.createEl(\"strong\", { text: \"Starting...\" });\n\n    // Track current step for animation\n    const updateProgress = (step: string, details?: string) => {\n      progressContent.empty();\n      progressContent.setText(\"ðŸ”„ \");\n      progressContent.createEl(\"strong\", { text: step });\n      if (details) {\n        progressContent.createEl(\"br\");\n        progressContent.createSpan({ cls: \"progress-details\", text: details });\n      }\n      this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;\n    };\n\n    // For streaming tokens\n    let streamingEl: HTMLElement | null = null;\n    let streamingContent = \"\";\n\n\n    try {\n      let finalAnswer: StreamEventAnswer | null = null;\n\n      // Use streaming API\n      for await (const event of this.plugin.askQuestionStreaming(question)) {\n        switch (event.type) {\n          case \"start\":\n            updateProgress(\"Connecting...\");\n            break;\n\n          case \"status\":\n            updateProgress(event.message);\n            break;\n\n          case \"retrieve_complete\":\n            updateProgress(\n              `ðŸ“š Retrieved ${event.docs_count} documents`,\n              event.sources.slice(0, 3).map((s) => \n                `â€¢ ${s.source.split(\"/\").pop()?.replace(\".md\", \"\") || s.source}`\n              ).join(\"<br>\")\n            );\n            break;\n\n          case \"ttft\":\n            // Log Time To First Token\n            console.debug(`âš¡ [ObsidianRAG] Time to First Token: ${event.seconds}s`);\n            break;\n\n          case \"token\": {\n            // First token: switch from progress to streaming display\n            if (!streamingEl) {\n              progressEl.remove();\n              streamingEl = this.containerEl_messages.createDiv(\n                \"obsidianrag-message assistant streaming\"\n              );\n              const contentDiv = streamingEl.createDiv(\"message-content\");\n              contentDiv.createDiv(\"streaming-text streaming-content\");\n            }\n            // Append token and render as markdown\n            streamingContent += event.content;\n            const textEl = streamingEl.querySelector(\".streaming-text\");\n            if (textEl) {\n              // Clear and re-render markdown for live preview\n              (textEl as HTMLElement).empty();\n              void MarkdownRenderer.render(\n                this.app,\n                streamingContent,\n                textEl as HTMLElement,\n                \"\",\n                this\n              );\n            }\n            // Auto-scroll\n            this.containerEl_messages.scrollTop = this.containerEl_messages.scrollHeight;\n            break;\n          }\n\n          case \"generate_complete\":\n            // This may come if not using token streaming\n            if (!streamingEl) {\n              updateProgress(\n                \"âœï¸ Generating answer...\",\n                event.answer_preview.substring(0, 100) + \"...\"\n              );\n            }\n            break;\n\n          case \"answer\":\n            finalAnswer = event;\n            break;\n\n          case \"error\":\n            progressEl.remove();\n            if (streamingEl) streamingEl.remove();\n            this.addMessage({\n              role: \"assistant\",\n              content: `âŒ Error: ${event.message}`,\n              timestamp: new Date(),\n            });\n            return;\n\n          case \"done\":\n            break;\n        }\n      }\n\n      // Remove progress if still showing\n      if (progressEl.parentElement) {\n        progressEl.remove();\n      }\n\n      // Add final answer with proper formatting\n      if (finalAnswer) {\n        const vaultPath = (this.app.vault.adapter as { basePath: string }).basePath;\n        const sourcesWithScores: SourceInfo[] = [];\n        \n        for (const s of finalAnswer.sources || []) {\n          let source = s.source;\n          // Remove vault path prefix\n          if (source.startsWith(vaultPath)) {\n            source = source.substring(vaultPath.length);\n            if (source.startsWith(\"/\")) {\n              source = source.substring(1);\n            }\n          }\n          // Remove .md extension for display\n          let displayPath = source;\n          if (displayPath.endsWith(\".md\")) {\n            displayPath = displayPath.substring(0, displayPath.length - 3);\n          }\n          \n          // Verify the file exists in vault\n          const fileWithMd = source.endsWith(\".md\") ? source : source + \".md\";\n          const file = this.app.vault.getAbstractFileByPath(fileWithMd) \n                    || this.app.vault.getAbstractFileByPath(source);\n          \n          if (file) {\n            sourcesWithScores.push({\n              path: displayPath,\n              displayName: displayPath.split(\"/\").pop() || displayPath,\n              score: s.score,\n              exists: true,\n            });\n          } else {\n            // Try to find by name (case-insensitive search)\n            const baseName = displayPath.split(\"/\").pop() || displayPath;\n            const allFiles = this.app.vault.getMarkdownFiles();\n            const matchingFile = allFiles.find(f => \n              f.basename.toLowerCase() === baseName.toLowerCase()\n            );\n            \n            if (matchingFile) {\n              const matchPath = matchingFile.path.endsWith(\".md\") \n                ? matchingFile.path.substring(0, matchingFile.path.length - 3)\n                : matchingFile.path;\n              sourcesWithScores.push({\n                path: matchPath,\n                displayName: matchingFile.basename,\n                score: s.score,\n                exists: true,\n              });\n            } else {\n              // File doesn't exist - still show but mark as non-existent\n              // File doesn't exist - skip it entirely\n              console.debug(`[ObsidianRAG] Skipping non-existent source: ${displayPath}`);\n            }\n          }\n        }\n\n        const seen = new Set<string>();\n        const uniqueSorted = sourcesWithScores\n          .filter((s) => s.exists !== false)  // Only include existing files\n          .sort((a, b) => b.score - a.score)\n          .filter((s) => {\n            if (seen.has(s.path)) return false;\n            seen.add(s.path);\n            return true;\n          });\n\n        // If we were streaming, upgrade the streaming element to final rendered markdown\n        if (streamingEl) {\n          // Remove streaming class and cursor animation\n          streamingEl.removeClass(\"streaming\");\n          const textEl = streamingEl.querySelector(\".streaming-text\");\n          if (textEl) {\n            textEl.removeClass(\"streaming-content\");\n            // Re-render as proper markdown\n            textEl.empty();\n            void MarkdownRenderer.render(\n              this.app,\n              finalAnswer.answer,\n              textEl as HTMLElement,\n              \"\",\n              this\n            );\n          }\n          \n          // Add sources to the existing streaming element\n          if (uniqueSorted.length > 0 && this.plugin.settings.showSourceLinks) {\n            const sourcesEl = streamingEl.createDiv(\"message-sources\");\n            sourcesEl.createEl(\"strong\", { text: \"Sources (by relevance): \" });\n\n            uniqueSorted.forEach((source, i) => {\n              if (i > 0) sourcesEl.appendText(\" \");\n              \n              const sourceContainer = sourcesEl.createSpan(\"source-item\");\n              const scoreIndicator = this.getScoreIndicator(source.score);\n              sourceContainer.appendText(scoreIndicator);\n              \n              if (source.exists !== false) {\n                // File exists - create clickable link\n                const link = sourceContainer.createEl(\"a\", { \n                  text: source.displayName, \n                  cls: \"internal-link\" \n                });\n                link.addEventListener(\"click\", (e) => {\n                  e.preventDefault();\n                  this.app.workspace.openLinkText(source.path, \"\");\n                });\n              } else {\n                // File doesn't exist - just show text (no link)\n                sourceContainer.createSpan({ \n                  text: source.displayName,\n                  cls: \"source-not-found\"\n                });\n              }\n            });\n          }\n          \n          // Store message in history\n          this.messages.push({\n            role: \"assistant\",\n            content: finalAnswer.answer,\n            sources: uniqueSorted,\n            timestamp: new Date(),\n          });\n        } else {\n          // No streaming happened, add message normally\n          this.addMessage({\n            role: \"assistant\",\n            content: finalAnswer.answer,\n            sources: uniqueSorted,\n            timestamp: new Date(),\n          });\n        }\n      }\n    } catch (error) {\n      progressEl.remove();\n      this.addMessage({\n        role: \"assistant\",\n        content: `âŒ Error: ${error}`,\n        timestamp: new Date(),\n      });\n    }\n  }\n\n  addMessage(message: ChatMessage) {\n    this.messages.push(message);\n\n    const messageEl = this.containerEl_messages.createDiv(\n      `obsidianrag-message ${message.role}`\n    );\n\n    // Render content as markdown (use empty sourcePath to prevent internal link resolution)\n    const contentEl = messageEl.createDiv(\"message-content\");\n    void MarkdownRenderer.render(\n      this.app,\n      message.content,\n      contentEl,\n      \"\",\n      this\n    );\n\n    // Add sources if present (already sorted by relevance)\n    if (\n      message.sources &&\n      message.sources.length > 0 &&\n      this.plugin.settings.showSourceLinks\n    ) {\n      const sourcesEl = messageEl.createDiv(\"message-sources\");\n      sourcesEl.createEl(\"strong\", { text: \"Sources (by relevance): \" });\n\n      message.sources.forEach((source, i) => {\n        if (i > 0) sourcesEl.appendText(\" \");\n        \n        // Create a container for each source with score indicator\n        const sourceContainer = sourcesEl.createSpan(\"source-item\");\n        \n        // Add relevance indicator (emoji based on score)\n        const scoreIndicator = this.getScoreIndicator(source.score);\n        sourceContainer.appendText(scoreIndicator);\n        \n        if (source.exists !== false) {\n          // File exists - create clickable link\n          const link = sourceContainer.createEl(\"a\", { \n            text: source.displayName, \n            cls: \"internal-link\" \n          });\n          link.setAttribute(\"title\", `Relevance: ${(source.score * 100).toFixed(1)}%`);\n          link.addEventListener(\"click\", (e) => {\n            e.preventDefault();\n            this.app.workspace.openLinkText(source.path, \"\");\n          });\n        } else {\n          // File doesn't exist - just show text\n          const span = sourceContainer.createSpan({ \n            text: source.displayName,\n            cls: \"source-not-found\"\n          });\n          span.setAttribute(\"title\", `File not found in vault`);\n        }\n      });\n    }\n\n    // Scroll to bottom\n    this.containerEl_messages.scrollTop =\n      this.containerEl_messages.scrollHeight;\n  }\n\n  /**\n   * Get an emoji indicator based on the relevance score\n   */\n  getScoreIndicator(score: number): string {\n    if (score >= 0.8) return \"ðŸŸ¢\";      // High relevance\n    if (score >= 0.6) return \"ðŸŸ¡\";      // Medium-high relevance\n    if (score >= 0.4) return \"ðŸŸ \";      // Medium relevance\n    return \"ðŸ”´\";                         // Lower relevance\n  }\n\n  async onClose(): Promise<void> {\n    // Cleanup periodic status check\n    if (this.statusInterval) {\n      window.clearInterval(this.statusInterval);\n      this.statusInterval = null;\n    }\n    this.statusEl = null;\n    await Promise.resolve();\n  }\n}\n\n// ============================================================================\n// Settings Tab\n// ============================================================================\n\nclass ObsidianRAGSettingTab extends PluginSettingTab {\n  plugin: ObsidianRAGPlugin;\n  private statusRefreshInterval: number | null = null;\n  private availableModels: string[] = [];\n\n  constructor(app: App, plugin: ObsidianRAGPlugin) {\n    super(app, plugin);\n    this.plugin = plugin;\n  }\n\n  display(): void {\n    const { containerEl } = this;\n    containerEl.empty();\n\n    // Fetch available models from Ollama and then render\n    void this.plugin.getOllamaModels().then(models => {\n      this.availableModels = models;\n      this.renderSettings(containerEl);\n    });\n  }\n\n  renderSettings(containerEl: HTMLElement): void {\n    containerEl.empty();\n\n    // Server Status Section (live)\n    void this.renderServerStatus(containerEl);\n\n    // Configuration Section\n    new Setting(containerEl).setName(\"Configuration\").setHeading();\n\n    // Python Path\n    new Setting(containerEl)\n      .setName(\"Backend command\")\n      .setDesc(\"Path to obsidianrag-server or 'obsidianrag' if installed globally\")\n      .addText((text) =>\n        text\n          .setPlaceholder(\"/usr/local/bin/obsidianrag-server\")\n          .setValue(this.plugin.settings.pythonPath)\n          .onChange(async (value) => {\n            this.plugin.settings.pythonPath = value;\n            await this.plugin.saveSettings();\n          })\n      );\n\n    // Server Port\n    new Setting(containerEl)\n      .setName(\"Server port\")\n      .setDesc(\"Port for the backend API server\")\n      .addText((text) =>\n        text\n          .setPlaceholder(\"8000\")\n          .setValue(String(this.plugin.settings.serverPort))\n          .onChange(async (value) => {\n            const port = parseInt(value) || DEFAULT_PORT;\n            this.plugin.settings.serverPort = port;\n            await this.plugin.saveSettings();\n          })\n      );\n\n    // LLM Model - dynamically populated from Ollama\n    const modelSetting = new Setting(containerEl)\n      .setName(\"LLM model\")\n      .setDesc(\"Ollama model to use for answering questions\");\n\n    if (this.availableModels.length > 0) {\n      modelSetting.addDropdown((dropdown) => {\n        // Add all available models from Ollama\n        this.availableModels.forEach(model => {\n          dropdown.addOption(model, model);\n        });\n        \n        // Set current value, or first available if current not in list\n        const currentModel = this.plugin.settings.llmModel;\n        if (this.availableModels.includes(currentModel)) {\n          dropdown.setValue(currentModel);\n        } else if (this.availableModels.length > 0) {\n          // Current model not available, switch to first available\n          dropdown.setValue(this.availableModels[0]);\n          this.plugin.settings.llmModel = this.availableModels[0];\n          void this.plugin.saveSettings();\n          new Notice(`Model '${currentModel}' not found. Switched to '${this.availableModels[0]}'`);\n        }\n        \n        dropdown.onChange(async (value) => {\n          this.plugin.settings.llmModel = value;\n          await this.plugin.saveSettings();\n        });\n      });\n    } else {\n      // Ollama not available - show warning and text input\n      modelSetting\n        .setDesc(\"âš ï¸ Could not connect to Ollama. Make sure Ollama is running (ollama serve).\")\n        .addText((text) =>\n          text\n            .setPlaceholder(\"gemma3\")\n            .setValue(this.plugin.settings.llmModel)\n            .onChange(async (value) => {\n              this.plugin.settings.llmModel = value;\n              await this.plugin.saveSettings();\n            })\n        );\n    }\n\n    // RAG Settings Section\n    new Setting(containerEl).setName(\"RAG\").setHeading();\n\n    // Use Reranker\n    new Setting(containerEl)\n      .setName(\"Use reranker\")\n      .setDesc(\"Enable CrossEncoder reranking for better relevance (slower but more accurate)\")\n      .addToggle((toggle) =>\n        toggle\n          .setValue(this.plugin.settings.useReranker)\n          .onChange(async (value) => {\n            this.plugin.settings.useReranker = value;\n            await this.plugin.saveSettings();\n          })\n      );\n\n    // Auto-start\n    new Setting(containerEl)\n      .setName(\"Auto-start server\")\n      .setDesc(\"Automatically start the backend when Obsidian opens\")\n      .addToggle((toggle) =>\n        toggle\n          .setValue(this.plugin.settings.autoStartServer)\n          .onChange(async (value) => {\n            this.plugin.settings.autoStartServer = value;\n            await this.plugin.saveSettings();\n          })\n      );\n\n    // Show sources\n    new Setting(containerEl)\n      .setName(\"Show source links\")\n      .setDesc(\"Display links to source notes in answers\")\n      .addToggle((toggle) =>\n        toggle\n          .setValue(this.plugin.settings.showSourceLinks)\n          .onChange(async (value) => {\n            this.plugin.settings.showSourceLinks = value;\n            await this.plugin.saveSettings();\n          })\n      );\n\n    // Server controls\n    new Setting(containerEl).setName(\"Server controls\").setHeading();\n\n    new Setting(containerEl)\n      .setName(\"Start server\")\n      .setDesc(\"Manually start the backend server\")\n      .addButton((button) =>\n        button.setButtonText(\"Start\").onClick(async () => {\n          await this.plugin.startServer();\n          this.display();\n        })\n      );\n\n    new Setting(containerEl)\n      .setName(\"Stop server\")\n      .setDesc(\"Stop the backend server\")\n      .addButton((button) =>\n        button.setButtonText(\"Stop\").onClick(async () => {\n          await this.plugin.stopServer();\n          this.display();\n        })\n      );\n\n    new Setting(containerEl)\n      .setName(\"Reindex vault\")\n      .setDesc(\"Force reindex all notes in the vault\")\n      .addButton((button) =>\n        button\n          .setButtonText(\"Reindex\")\n          .setWarning()\n          .onClick(async () => {\n            await this.plugin.reindexVault();\n          })\n      );\n\n    // Vault Statistics Section\n    void this.renderVaultStats(containerEl);\n\n    // Help section\n    new Setting(containerEl).setName(\"Requirements\").setHeading();\n    const helpEl = containerEl.createEl(\"div\", { cls: \"setting-item-description\" });\n    helpEl.createEl(\"p\", { text: \"This plugin requires:\" });\n    const ul = helpEl.createEl(\"ul\");\n    \n    const hLi1 = ul.createEl(\"li\");\n    hLi1.createEl(\"strong\", { text: \"Python 3.11+\" });\n    hLi1.appendText(\" installed and accessible\");\n\n    const hLi2 = ul.createEl(\"li\");\n    hLi2.createEl(\"strong\", { text: \"obsidianrag\" });\n    hLi2.appendText(\" package: \");\n    hLi2.createEl(\"code\", { text: \"pip install obsidianrag\" });\n\n    const hLi3 = ul.createEl(\"li\");\n    hLi3.createEl(\"strong\", { text: \"Ollama\" });\n    hLi3.appendText(\" running locally with at least one model\");\n\n    const pLink = helpEl.createEl(\"p\", { text: \"Install Ollama from \" });\n    pLink.createEl(\"a\", { text: \"ollama.ai\", href: \"https://ollama.ai\" });\n\n    // Reset Setup\n    new Setting(containerEl).setName(\"Advanced\").setHeading();\n    \n    new Setting(containerEl)\n      .setName(\"Reset to defaults\")\n      .setDesc(\"Reset all settings to their default values\")\n      .addButton((button) =>\n        button\n          .setButtonText(\"Reset all settings\")\n          .setWarning()\n          .onClick(async () => {\n            // Keep hasCompletedSetup true so wizard doesn't show again\n            const keepSetupComplete = this.plugin.settings.hasCompletedSetup;\n            \n            // Reset to defaults\n            this.plugin.settings = {\n              pythonPath: \"/usr/local/bin/obsidianrag-server\",\n              serverPort: 8000,\n              llmModel: \"gemma3\",\n              autoStartServer: true,\n              showSourceLinks: true,\n              useReranker: true,\n              hasCompletedSetup: keepSetupComplete,\n            };\n            \n            await this.plugin.saveSettings();\n            new Notice(\"Settings reset to defaults\");\n            this.display(); // Refresh the settings page\n          })\n      );\n\n    new Setting(containerEl)\n      .setName(\"Reset setup wizard\")\n      .setDesc(\"Show the setup wizard again on next reload\")\n      .addButton((button) =>\n        button\n          .setButtonText(\"Reset wizard\")\n          .onClick(async () => {\n            this.plugin.settings.hasCompletedSetup = false;\n            await this.plugin.saveSettings();\n            new Notice(\"Setup wizard will show on next reload\");\n          })\n      );\n  }\n\n  private async renderServerStatus(containerEl: HTMLElement) {\n    const statusContainer = containerEl.createDiv(\"obsidianrag-settings-status\");\n    new Setting(statusContainer).setName(\"Server status\").setHeading();\n    \n    const statusEl = statusContainer.createDiv(\"status-display\");\n    \n    // Initial render\n    await this.updateServerStatusDisplay(statusEl);\n    \n    // Set up periodic refresh (every 3 seconds)\n    if (this.statusRefreshInterval) {\n      window.clearInterval(this.statusRefreshInterval);\n    }\n    this.statusRefreshInterval = window.setInterval(async () => {\n      await this.updateServerStatusDisplay(statusEl);\n    }, 3000);\n  }\n\n  private async updateServerStatusDisplay(statusEl: HTMLElement): Promise<void> {\n    const running = await this.plugin.isServerRunning();\n    \n    // Clear previous classes and content\n    statusEl.removeClass(\"status-online\", \"status-offline\");\n    statusEl.empty();\n    \n    if (running) {\n      statusEl.addClass(\"status-online\");\n      statusEl.createSpan({ cls: \"status-indicator\", text: \"â—\" });\n      statusEl.createSpan({ cls: \"status-text\", text: \" Server is running\" });\n      \n      // Fetch and display health info\n      try {\n        const response = await requestUrl(`http://127.0.0.1:${this.plugin.settings.serverPort}/health`);\n        if (response.status >= 200 && response.status < 300) {\n          const health = response.json as HealthResponse;\n          const detailsEl = statusEl.createDiv(\"status-details\");\n          detailsEl.createDiv({ text: `Version: ${health.version || \"unknown\"}` });\n          detailsEl.createDiv({ text: `Model: ${health.model || \"unknown\"}` });\n        }\n      } catch {\n        // Ignore fetch errors\n      }\n    } else {\n      statusEl.addClass(\"status-offline\");\n      statusEl.createSpan({ cls: \"status-indicator\", text: \"â—\" });\n      statusEl.createSpan({ cls: \"status-text\", text: \" Server is offline\" });\n    }\n  }\n\n  private async renderVaultStats(containerEl: HTMLElement) {\n    new Setting(containerEl).setName(\"Vault statistics\").setHeading();\n    \n    const statsContainer = containerEl.createDiv(\"obsidianrag-vault-stats\");\n    \n    const running = await this.plugin.isServerRunning();\n    \n    if (!running) {\n      statsContainer.setText(\"Start the server to view vault statistics.\");\n      return;\n    }\n    \n    statsContainer.setText(\"Loading statistics...\");\n    \n    const stats = await this.plugin.getStats();\n    \n    if (stats && !stats.error) {\n      statsContainer.empty();\n      const table = statsContainer.createEl(\"table\", { cls: \"stats-table\" });\n      \n      const rows = [\n        [\"Total notes\", String(stats.total_notes)],\n        [\"Total chunks\", String(stats.total_chunks)],\n        [\"Total words\", String(stats.total_words).replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\")],\n        [\"Avg words/chunk\", String(stats.avg_words_per_chunk)],\n        [\"Folders\", String(stats.folders)],\n        [\"Internal links\", String(stats.internal_links)],\n        [\"Vault\", stats.vault_path],\n      ];\n      \n      rows.forEach(([label, value]) => {\n        const row = table.createEl(\"tr\");\n        row.createEl(\"td\", { text: label, cls: \"stats-label\" });\n        row.createEl(\"td\", { text: value, cls: \"stats-value\" });\n      });\n    } else {\n      statsContainer.setText(stats?.error || \"Could not load statistics.\");\n    }\n  }\n\n  hide(): void {\n    if (this.statusRefreshInterval) {\n      window.clearInterval(this.statusRefreshInterval);\n      this.statusRefreshInterval = null;\n    }\n  }\n}\n","usedDeprecatedRules":[]}]
â€‰ELIFECYCLEâ€‰ Command failed with exit code 1.
